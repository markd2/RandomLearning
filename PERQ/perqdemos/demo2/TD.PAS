program td(input, output);exportsimports screen from screen;const {$Include TD.Dfs}var screenp: rasterptr;    c: char;    quitting:boolean;    param, pz, py, px: integer;function keyhit:boolean;function r(i, j:integer):integer;function random: integer;function sqroot(x: integer): integer;procedure clearscreen;procedure Sync;privateimports io_Unit from io_Unit;imports io_Others from io_Others;imports ioerrors from ioerrors;imports ControlStore from ControlStore;imports td1 from td1;imports td2 from td2;var hitkey: boolean;    TD, TDBin: MicroFile;    function keyhit;begin    if IOCread(TransKey, c)=IOEIOC then begin        if (ord('0')<=ord(c)) and (ord(c)<=ord('9'))        then begin            if hitkey then param:=0;            param:=param*10+(ord(c)-ord('0'));            hitkey:=false        end else            hitkey:=true;        keyhit:=hitkey    end else        keyhit:=falseend;procedure clearscreen;begin    rasterop(6, 768, 1024, 0, 0, 48, screenp, 0, 0, 48, screenp)end;procedure Sync;var OldT, NewT: Double;begin { Sync }  IOGetTime(OldT);  repeat IOGetTime(NewT)  until NewT[0] <> OldT[0]end { Sync };function sqroot;var v, i: integer;begin    LoadExpr(x);    LoadExpr(LOr(Shift(Sqrt,8),Shift(Sqrt,-8)));    InLineByte(191 {JCS});    StorExpr(v);    SqRoot:=vend;procedure help;begin    writeln(chr(12), 'Type:');    writeln('    a for rippling rectangles');    writeln('    b for sliding squares');    writeln('    c for xor circle');    writeln('    d for sliding lines');    writeln('    e for munching squares         *');    writeln('    f for tetra                    *');    writeln('    g for localop                  *');    writeln('    h for random circles');    writeln('    i for bouncing square');    writeln('    j for fractal contour maps');    writeln('    k for colliding balls');    writeln('    l for shaded spheres');    writeln('    m for a test pattern');    writeln('    n for Fredkin''s Pattern');    writeln('    p for EF1');    writeln('    q to quit');    writeln('    t to run the testprogram');    writeln('    x for setting px');    writeln('    y for setting py');    writeln('    z for setting pz');    writeln('    - for changing the sign of the parameter');    writeln(' ');    writeln('Those marked with an asterisk require a numeric parameter,');    writeln('which should be typed before the letter which runs the');    writeln('program.  For example');    writeln('    17e');    writeln('will run munching squares with 17 for a parameter.');    writeln('If you don''t give a number, the last number you typed');    writeln('will be used.');    while not keyhit doend;function efmod (a, b: integer): integer;var efm: integer;begin    efm:=a-(a div b)*b;    if efm<0 then efmod:=efm+b else efmod:=efm;end;    procedure plot(x,y:integer);var xd, yd: integer;begin   xd:=efmod((x+384), 768);   yd:=efmod((512-y), 1024);   LoadExpr(1);   LoadExpr(xd);   LoadExpr(yd);   LoadAdr(SScreenP);   InLineByte(239 {lddw});   LoadExpr(Lor(Shift(SetDot,8),Shift(SetDot,-8)));{LoadExpr(SSD)}   InLineByte(228 {TLATE});   InLineByte(191 {JCS});end;procedure testprogram;begin     clearscreen;    plot(px, py);    plot(px+1, py);    plot(px-1, py);    plot(px, py+1);    plot(px, py-1);    writeln(px);    writeln(py);    writeln(efmod(px,py));    while not keyhit do;end;   procedure efpattern;const piy=32240; pix=512;var x, y: integer;begin    x:=0;    y:=piy;    clearscreen;    while not keyhit do     begin       y:=y-x div pix;       x:=x+y div pix;       plot(x,y);     endend;procedure efdelay;const delay=500;var i,j: integer;begin    for i:=0 to delay do begin for j:=0 to delay do ; end;end;procedure ef1;var i, k, m: integer;label 25;begin    clearscreen;    writeln(chr(12));    for i:= 1 to 16 do writeln(' ');    writeln('                                         3R                                         CC');    efdelay;    while not keyhit do      begin      for m:=1 to 16 do        begin        for k := 1 to 16 do          begin              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    127, 512, 48, screenp);              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    129, 512, 48, screenp);              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    128, 511, 48, screenp);              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    128, 513, 48, screenp);              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    128, 512, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    127,   1, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    129,   1, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    128,   0, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    128,   2, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    128,   1, 48, screenp);          end;        if keyhit then goto 25;        efdelay;        if keyhit then goto 25;       end;              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    128, 512, 48, screenp);              rasterop(6, 510, 510, 128, 512, 48, screenp,                                    128,   1, 48, screenp);              rasterop(6, 510, 510, 128,   1, 48, screenp,                                    128, 512, 48, screenp);      end;25:   clearscreen;end;                      procedure ripple;const XSIZE = 380;      YSIZE = 512;var x, y, xinc, yinc: integer;begin    xinc:=4;    yinc:=4;    clearscreen;    x:=0;    y:=0;    while not keyhit do begin        if (x<>0) and (y<>0) then            rasterop(1, x*2, y*2, 384-x, 512-y, 48, screenp,                                  384-x, 512-y, 48, screenp);        x:=x+xinc;        if (x=XSIZE) or (x=0) then xinc:=-xinc;        y:=y+yinc;        if (y=YSIZE) or (y=0) then yinc:=-yinc    endend;procedure bounce1;const XSIZE = 704;      YSIZE = 960;var x, y, xinc, yinc, i: integer;begin    xinc:=4;    yinc:=4;    clearscreen;    x:=0;    y:=0;    while not keyhit do begin        rasterop(1, 64, 64, x, y, 48, screenp, x, y, 48, screenp);        x:=x+xinc;        if (x=XSIZE) or (x=0) then xinc:=-xinc;        y:=y+yinc;        if (y=YSIZE) or (y=0) then yinc:=-yinc;        for i:=1 to 1000 do    endend;procedure circle1;var x, y: integer;begin    clearscreen;    for x:=0 to 180 do begin        y:=0;        while x*x+y*y<180*180 do y:=y+1;        if (x<>0) and (y<>0) then            rasterop(1, 2*x, 2*y, 384-x, 512-y, 48, screenp,                                  384-x, 512-y, 48, screenp)    end;    while not keyhit doend;procedure lineslide;var x, y, dx, dy, x1, y1, dx1, dy1: integer;begin    clearscreen;    x:=r(0, 767);    y:=r(768, 1023);    x1:=r(0, 767);    y1:=r(768, 1023);    dx:=r(1, 3);    dy:=r(1, 3);    dx1:=r(-3, -1);    dy1:=r(-3, -1);    while not keyhit do begin        x:=x+dx;        if(x<0) or (767<x) then begin            x:=x-2*dx;            dx:=-dx;        end;        y:=y+dy;        if(y<768) or (1023<y) then begin            y:=y-2*dy;            dy:=-dy;        end;        x1:=x1+dx1;        if(x1<0) or (767<x1) then begin            x1:=x1-2*dx1;            dx1:=-dx1;        end;        y1:=y1+dy1;        if(y1<768) or (1023<y1) then begin            y1:=y1-2*dy1;            dy1:=-dy1;        end;        line(XorLine, x, y, x1, y1, screenp);        rasterop(0, 768, 1023, 0, 0, 48, screenp, 0, 1, 48, screenp);        rasterop(3, 768, 1, 0, 1023, 48, screenp, 0, 1023, 48, screenp)    endend;procedure munch;var x, y, t, dt: integer;begin    clearscreen;    dt:=param;    t:=0;    while not keyhit do begin        for x:=0 to 383 do begin            y:=land(511, lxor(x, t));            rasterop(1, 2, 2, 2*x, 2*y, 48, screenp, 2*x, 2*y, 48, screenp)        end;        t:=t+dt    endend;procedure tetra;const MAXN=300;var dx, dy:array[1..4] of integer;    x, y:array[1..MAXN] of array[1..4] of integer;    i, j, k, l, n: integer;    first: boolean;begin    n:=param;    if n<1 then n:=1 else if MAXN<n then n:=MAXN;    clearscreen;    for i:=1 to 4 do begin        x[n][i]:=r(0, 767);        y[n][i]:=r(0, 1023);        dx[i]:=r(3, 6);        dy[i]:=r(3, 6)    end;    first:=true;    l:=n;    while not keyhit do begin        for k:=1 to n do begin            if not first then for i:=1 to 4 do                for j:=1 to (i-1) do                    line(XorLine, x[k][i], y[k][i], x[k][j], y[k][j], screenp);            for i:=1 to 4 do begin                x[k][i]:=x[l][i]+dx[i];                if (x[k][i]<0) or (768<=x[k][i]) then begin                    x[k][i]:=x[k][i]-2*dx[i];                    dx[i]:=-dx[i]                end;                y[k][i]:=y[l][i]+dy[i];                if (y[k][i]<0) or (1024<=y[k][i]) then begin                    y[k][i]:=y[k][i]-2*dy[i];                    dy[i]:=-dy[i]                end;                for j:=1 to (i-1) do                    line(XorLine, x[k][i], y[k][i], x[k][j], y[k][j], screenp)            end;            l:=k        end;        first:=false    endend;{------------------------------------------------------------------------     RandomNumbers - Random number generator.      J. P. Strait    15 Sep 80.      Copyright (C) Three Rivers Computer Corporation, 1980.                  Module RandomNumbers contains two routines:              InitRandom - initializes the random number generator.                Random - a function which returns a new random number each time                 it is referenced.                       There is currently no way to seed the generator.            Random is a feedback shift-register pseudo-random number generator.      The algorithm used is one described in the article:                 'Generalized Feedback Shift Register Pseudorandom Number                 Generator'           T. G. Lewis and W. H. Payne           JACM Vol. 20, No. 3, July 1973, pp. 456-468.                 Random produces multidimensional pseudo-random numbers equally      distributed in the interval -32768..32767 and has a period of      2^98.------------------------------------------------------------------------}{------------------------------------------------------------------------  Change log:             1 Jun 81  BAM  V1.2  Add comments.      17 Sep 80  JPS  V1.1  Correct an error in the table.      20 Jun 81  JPS  V1.2  Use microcode for TD.------------------------------------------------------------------------}const RandomVersion = '1.2';            var Table: array[0..P-1] of integer;Procedure InitRandom;{------------------------------------------------------------------------  Abstract: Initialize the random number generator.  Every time this is             called, the random numbers start over at the same place.------------------------------------------------------------------------} begin { InitRandom }  Table[ 0] := #020651;  Table[ 1] := #147643;  Table[ 2] := #164707;  Table[ 3] := #125262;  Table[ 4] := #104256;  Table[ 5] := #074760;  Table[ 6] := #114470;  Table[ 7] := #052607;  Table[ 8] := #045551;  Table[ 9] := #134031;  Table[10] := #024107;  Table[11] := #030766;  Table[12] := #154073;  Table[13] := #114777;  Table[14] := #024540;  Table[15] := #111012;  Table[16] := #011042;  Table[17] := #104067;  Table[18] := #056332;  Table[19] := #142244;  Table[20] := #131107;  Table[21] := #034074;  Table[22] := #052641;  Table[23] := #163046;  Table[24] := #026303;  Table[25] := #131352;  Table[26] := #077724;  Table[27] := #002462;  Table[28] := #110775;  Table[29] := #127346;  Table[30] := #020100;  Table[31] := #137011;  Table[32] := #136163;  Table[33] := #145552;  Table[34] := #144223;  Table[35] := #134111;  Table[36] := #075001;  Table[37] := #075221;  Table[38] := #176705;  Table[39] := #000210;  Table[40] := #103625;  Table[41] := #120246;  Table[42] := #062614;  Table[43] := #016147;  Table[44] := #054723;  Table[45] := #151200;  Table[46] := #105223;  Table[47] := #021001;  Table[48] := #016224;  Table[49] := #073377;  Table[50] := #150716;  Table[51] := #014557;  Table[52] := #112613;  Table[53] := #037466;  Table[54] := #002677;  Table[55] := #052542;  Table[56] := #063572;  Table[57] := #105462;  Table[58] := #106436;  Table[59] := #063302;  Table[60] := #053171;  Table[61] := #133243;  Table[62] := #113130;  Table[63] := #123222;  Table[64] := #072371;  Table[65] := #041043;  Table[66] := #163614;  Table[67] := #037432;  Table[68] := #147330;  Table[69] := #153403;  Table[70] := #130306;  Table[71] := #056455;  Table[72] := #175640;  Table[73] := #120567;  Table[74] := #100601;  Table[75] := #042371;  Table[76] := #154635;  Table[77] := #051133;  Table[78] := #074252;  Table[79] := #174525;  Table[80] := #163223;  Table[81] := #052022;  Table[82] := #022564;  Table[83] := #135512;  Table[84] := #021760;  Table[85] := #006743;  Table[86] := #006451;  Table[87] := #067445;  Table[88] := #106210;  Table[89] := #025417;  Table[90] := #066566;  Table[91] := #062723;  Table[92] := #124224;  Table[93] := #144643;  Table[94] := #164502;  Table[95] := #025342;  Table[96] := #003521;  Table[97] := #024050;  LoadExpr(LOr(Shift(InitRan,8),Shift(InitRan,-8)));  InLineByte(191 {JCS}) end { InitRandom };function r;var k:integer;begin    LoadAdr(Table);    LoadExpr(LOr(Shift(Ran,8),Shift(Ran,-8)));    InLineByte(191 {JCS});    StorExpr(k);    k:=k mod (j-i+1);    if k<0 then r:=k+j+1    else r:=k+iend;function random;var r: Integer;begin    LoadAdr(Table);    LoadExpr(LOr(Shift(Ran,8),Shift(Ran,-8)));    InLineByte(191 {JCS});    StorExpr(r);    random := rend;begin    reset(input);    rewrite(output);    Reset(TDBin, 'TD.Bin');    LoadControlStore(TDBin);    Close(TDBin);    Reset(TD,'TD.BIN');    LoadControlStore(TD);    Close(TD);    initrandom;    hitkey:=false;    param:=0;    screenp:=SScreenP;    c:='?';    quitting:=false;    while not quitting do begin        case c of        'a':ripple;        'b':bounce1;        'c':circle1;        'd':lineslide;        'e':munch;        'f':tetra;        'g':localop;        'h':circle2;        'i':bounce2;        'j':fractal;        'k':bounce3;        'l':spheres;        'm':testpattern;        'n':efpattern;        'p':ef1;        'q':quitting:=true;        't':testprogram;        'x': begin px:=param; while not keyhit do ; end;        'y': begin py:=param; while not keyhit do ; end;        'z': begin pz:=param; while not keyhit do ; end;        '-': begin param:=-param; while not keyhit do ; end;        otherwise: help        end    endend.module td2;exportsprocedure bounce3;procedure spheres;procedure testpattern;privateimports td from td;procedure bounce3;const N=20;type tcircle = array[0..200] of integer;var i, j, a, b, d, x0, y0, t: integer;    x, y, vx, vy:array[0..N] of integer;    circle: ^tcircle;    l0, VAi, VPi, VAj, VPj: Integer;begin    new(0,4,circle);    rasterop(6, 20, 20, 0, 0, 4, circle, 0, 0, 4, circle);    for i:=1 to 9 do begin        j:=sqroot(10*10-i*i)+1;        rasterop(7, 2*i, 2*j, 10-i, 10-j, 4, circle, 10-i, 10-j, 4, circle);        rasterop(7, 2*j, 2*i, 10-j, 10-i, 4, circle, 10-j, 10-i, 4, circle)    end;    clearscreen;    for i:=0 to N do begin        x[i]:=r(0, 767-20);        y[i]:=r(0, 1023-20);        vx[i]:=r(-6, 6);        vy[i]:=r(-6, 6);        rasterop(6, 20, 20, x[i], y[i], 48, screenp, 0, 0, 4, circle)    end;    while not keyhit do begin        Sync;        for i:=0 to N do begin            x0:=x[i];            y0:=y[i];            x[i]:=x[i]+vx[i];            if x[i]<0 then begin                x[i]:=-x[i];                vx[i]:=-vx[i]            end else if x[i]>767-20 then begin                x[i]:=2*(767-20)-x[i];                vx[i]:=-vx[i]            end;            y[i]:=y[i]+vy[i];            if y[i]<0 then begin                y[i]:=-y[i];                vy[i]:=-vy[i]            end else if y[i]>1023-20 then begin                y[i]:=2*(1023-20)-y[i];                vy[i]:=-vy[i]            end;            rasterop(6, 20, 20, x0, y0, 48, screenp, 0, 0, 4, circle);            rasterop(6, 20, 20, x[i], y[i], 48, screenp, 0, 0, 4, circle)        end;        for i:=0 to N do begin            for j:=i+1 to N do begin                x0:=x[i]-x[j];                y0:=y[i]-y[j];                if (abs(x0)<20) and (abs(y0)<20) and (x0*x0+y0*y0<20*20) then                begin                    l0 := SqRoot(x0*x0+y0*y0);                    VAi := (vx[i]*x0 + vy[i]*y0) div l0;                           { component along axis }                    VPi := (vx[i]*y0 - vy[i]*x0) div l0;                           { component perpendicular to axis }                    VAj := (vx[j]*x0 + vy[j]*y0) div l0;                           { component along axis }                    VPj := (vx[j]*y0 - vy[j]*x0) div l0;                           { component perpendicular to axis }                    t := VAi;   { bounce }                    VAi := VAj;                    VAj := t;                    vx[i] := (VAi * x0 + VPi * y0) div l0;                    vy[i] := (VAi * y0 - VPi * x0) div l0;                    vx[j] := (VAj * x0 + VPj * y0) div l0;                    vy[j] := (VAj * y0 - VPj * x0) div l0                end            end        end    endend;procedure spheres;const NX=48;      NY=-36;      NZ=80;      {$I TD.Dfs}type ScreenLine = array[0..47] of packed array[0..15] of Boolean;     WholeScreen = array[0..0] of ScreenLine;     pWholeScreen = ^WholeScreen;var done: boolean;    Screen: pWholeScreen;procedure sphere(x0, y0, rad:integer);var i, x, y, z, zsq, P1, P2: integer;begin    for y:=-rad to rad do begin        if not done then begin            P1 := Rad*Rad - y*y;            P2 := Ny * y;            done:=keyhit;            for x:=-rad to rad do begin               zsq:=P1 - x*x;               if zsq>=0 then begin                   i:=Nx*x+P2+NZ*Z;                   LoadExpr(r(0,Rad*100)>i);                   LoadExpr(X + X0);                   LoadExpr(Y + Y0);                   LoadAdr(ScreenP);                   InLineByte(239 {LDDW});                   LoadExpr(LOr(Shift(SetDot,8),Shift(SetDot,-8)));                   InLineByte(228 {TLATE1});                   InLineByte(191 {JCS})               end           end       end    endend;begin    clearscreen;    Screen := Recast(ScreenP, pWholeScreen);    done:=false;    while not done do        sphere(r(180, 767-180), r(180, 1023-180), r(50, 180))end;procedure testpattern;var i, j: integer;begin    clearscreen;    i:=1;    j:=1;    while i<384 do begin        rasterop(1, 2*i, 2*i+256, 384-i, 384-i, 48, screenp,                                  384-i, 384-i, 48, screenp);        j:=j+1;        i:=i+j    end;    while not keyhit doend.