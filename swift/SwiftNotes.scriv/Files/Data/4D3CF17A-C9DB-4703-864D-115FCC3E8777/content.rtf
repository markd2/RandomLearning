{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Bold;\f1\froman\fcharset0 Palatino-Roman;\f2\fnil\fcharset0 Menlo-Regular;
\f3\froman\fcharset0 Palatino-BoldItalic;\f4\fswiss\fcharset0 Helvetica;\f5\fnil\fcharset0 .AppleSystemUIFontMonospaced-Regular;
\f6\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;\red22\green22\blue24;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c11373\c11373\c12157;\cssrgb\c100000\c100000\c100000;}
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 Swift Testing
\f1\b0 \
\
New and improved testing frameworkke\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\qc\partightenfactor0
\cf0 \ul \ulc0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\ulnone \
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 \

\f0\b https://developer.apple.com/xcode/swift-testing/
\f1\b0 \
\

\f0\b Clear Expressive API
\f1\b0 \
\
* declare complex behaviors with a small amount of code\
* #expect uses Swift expressions and operators\
	- captures evaluated values so can quickly understand what went wrong\
* Parameterized tests run the same test over a sequence of values\
* integrate seamlessly with Swift Concurrency and run in parallel by default\
\

\f2 @Test("Continents mentioned in videos", arguments: [\
    "A Beach",\
    "By the Lake",\
    "Camping in the Woods"\
])\
func mentionedContinents(videoName: String) async throws \{\
    let videoLibrary = try await VideoLibrary()\
    let video = try #require(await videoLibrary.video(named: videoName))\
    #expect(video.mentionedContinents.count <= 3)\
\}
\f1 \
\

\f0\b Custom test behaviors\

\f1\b0 \
Can customize behavior of test/suites using traits.\
Can describe the runtime conditions for a test\
	- which device a test should ruin on\
	- limt test to a certain OS system versions\
	- help in CI by specifying execution time limits\
\

\f2 @Test(.enabled(if: AppFeatures.isCommentingEnabled))\
func videoCommenting() async throws \{\
    let video = try #require(await videoLibrary.video(named: "A Beach"))\
    #expect(video.comments.contains("So picturesque!"))\
\}\

\f1 \

\f0\b Easy and Flexible Organization\

\f1\b0 \
Provides many ways to keep your tests organized.\
	- structure related tests using a hierarchy of groups and subgroups\
	- apply tags to flexibly manage, edit, and run tests with common characteristics across your test suite\
	- also give tests a descriptive name\
\

\f2 @Test("Check video metadata",\
      .tags(.metadata))\
func videoMetadata() \{\
    let video = Video(fileName: "By the Lake.mov")\
    let expectedMetadata = Metadata(duration: .seconds(90))\
    #expect(video.metadata == expectedMetadata)\
\}
\f1 \
\

\f0\b Tooling\

\f1\b0 \
work with tests and suites inside of xcrud\
inline presentations of tst results\
re-run specific arguments for parameterized tests for debugging\
\
run from the command line using SPM (yay!)\
\

\f0\b Open Source / Cross Platform\

\f1\b0 \
works on all major platforms.\
Tests can behave more consistently when moving between platforms.\
open source\
\

\f0\b works with XCTest
\f1\b0 \
\
can run side-by-side with newer SwiftTesting\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\qc\partightenfactor0
\cf0 \ul \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\ulnone \
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 \
https://developer.apple.com/documentation/testing/\
\

\f0\b intro blurb\

\f1\b0 Develop tests with more confidence and less code\
integrates seamlessly with SPM testing workflow\
customizable metadata\
scalable test execution\
\
- define test functions almost anywhere with a single attribute\
- group related tests into hierarchies using Swift's type system\
- integrate seamlessly with Swift Concurrency\
- Parameterize test functions\
- enable tests dynamically depending on runtime conditions\
	- hopefully there's a phase of moon attribute\
- paralleize tests in-process\
- categorize tests using tags\
- associate bugs directly with the tests that verify their fixes or repro their problems\
	- 
\f3\i\b interesting
\f1\i0\b0 \
\

\f0\b Defining Test Functions
\f1\b0 \
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/definingtests"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/definingtests}}\
\
"definite a test function to validate that code is working correctly:\
\
Article assumes the package or project has already been configured with a test target (c.f. {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/Xcode/test-coverage"}}{\fldrslt https://developer.apple.com/documentation/Xcode/test-coverage}})\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 import Testing\

\f1 \
Note:\
	- Only import the testing liberry into a test target\
	- importing into an application, libary, or binary target isn't supported / recommended\
	- test functions aren't stripped from binaries when building for release, so all sorts of stuff could be visible\
\

\f0\b Declaring a test function
\f1\b0 \
\

\f2 @Test func foodTruckExists() \{\
    // test logic goes here\
\}\

\f1 \
can be at file-scope or inside a type\
\
A type containing test functions is automatically a test suite.  c.f. {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/organizingtests"}}{\fldrslt https://developer.apple.com/documentation/testing/organizingtests}}\
\
The above function doesn't do much.  Add 
\f0\b expectations
\f1\b0  to the test function. c.f. Edmund Welles {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/expectations"}}{\fldrslt https://developer.apple.com/documentation/testing/expectations}}\
\
Can customize the test name's (so when it's surfaced in an IDE or command line" - can add a string literal to the @Test attribute\
\

\f2 @Test("Food truck exists") func foodTruckExists() \{ ... \}\

\f1 \
To further customize appearance and behavior of a test function, use traits like 
\f2 tags(_:)
\f1 \
\

\f0\b concurrent or throwing tests
\f1\b0 \
\
can decorate the test with async / throws / @MainActor\
\

\f0\b limiting availability\
\

\f1\b0 For running on newer versions of OS or language, use @available.  e.g.\

\f2 	@available(swift, introduced: 8.0, message: "Requires Swift 8.0 features to run")\

\f1 \
and can also use @available for things like an OS gate (@available(macOS 11.0, *))\
\
There's also migrating a test from XCTest, via {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/migratingfromxctest"}}{\fldrslt https://developer.apple.com/documentation/testing/migratingfromxctest}}\
\

\f0\b Test Suite Types
\f1\b0 \
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/organizingtests"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/organizingtests}}\
\
When working with a large chunk of functions, helpful to organize them into test suites.\
\
Two ways\
- placing it into a Swift type\
- placing it in a swift type and annotating that type with the @Suite attributt\
\
@Suite isn't required to recognize a type contains test functions.  Does allow customization of the test's appearance in tooling.  Traits like tags/disabled are inherited by the test in the suite\
\
Can have nested test suites\
\
tests within a suite run in parallel. c.f. {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/parallelization"}}{\fldrslt https://developer.apple.com/documentation/testing/parallelization}}\
\
customizing name\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 @Suite("Food truck tests") struct FoodTruckTests \{\
  @Test func foodTruckExists() \{ ... \}\
\}\

\f1 \

\f0\b test functions in a test suite type
\f1\b0 \
\
instance method test functions, the library calls that by initialziing an instance of the type, then calling the test function\
\
So these two are equivalent\
\

\f2 @Suite struct FoodTruckTests \{\
  @Test func foodTruckExists() \{ ... \}\
\}\
\
@Suite struct FoodTruckTests \{\
  func foodTruckExists() \{ ... \}\
\
\
  @Test static func staticFoodTruckExists() \{\
    let instance = FoodTruckTests()\
    instance.foodTruckExists()\
  \}\
\}\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \

\f0\b limitations / constraints on suite types\

\f1\b0 \
an initializer may be required\
	- may be implicit or explicit\
	- sync or async\
	- throwing or non-thorwing\
	- private/fileprivate / internal / package / public\
\
Test suite types must always be available - not annotated with @available\
\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/parallelization"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/parallelization}}\
Running tests serially or in parallel\
\
testing library uses task groups, and tests all run in the same process.\
\
number of tests that run concurrently s controlled by the runtime\
\
parallelization can be disabled on a per-function or a per-suite basis using serialized\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 @Test(.serialized, arguments: Food.allCases) func prepare(food: Food) \{\
  // This function will be invoked serially, once per food, because it has the\
  // .serialized trait.\
\}\
\
\
@Suite(.serialized) struct FoodTruckTests \{\
  @Test(arguments: Condiment.allCases) func refill(condiment: Condiment) \{\
    // This function will be invoked serially, once per condiment, because the\
    // containing suite has the .serialized trait.\
  \}\
\
\
  @Test func startEngine() async throws \{\
    // This function will not run while refill(condiment:) is running. One test\
    // must end before the other will start.\
  \}\
\}
\f1 \
\
when added to a parameterized test function, serialized causes that test to run its cases serially instead of paralle.\
\
When applied to a non-param test function, has no effect\
\
When applied to a test suite, causes it to run the contained test functions and sub-suites serially\
\
Recursively applied through embedded suites\
\
doesn't affect execution of a test relative to its peers or unrelated tests.\
\
has no effect if parallelization is globally disabled (e.g. --no-parallel to swift test)\
\

\f0\b Migrating from XCTest
\f1\b0 \
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/migratingfromxctest"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/migratingfromxctest}}\
\
Can coexist in the same file\
\
XCTest groups related sets of test methods in test calsses inheriting from XCTestCase.\
Can be free or global, or static or class members of a type.\
\
To convert XCTestCase to a suite, remove the XCTestCase CONFORMance.\
\
Swift structure or actor be used to better enforce concurrency saftey\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 // Before\
class FoodTruckTests: XCTestCase \{\
  ...\
\}\
\
// After\
struct FoodTruckTests \{\
  ...\
\}
\f1 \
\
XCtest - setup and tear down.  Use init instead.  and deinit for teardown (but need a class for that)\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  var batteryLevel: NSNumber!\
  override func setUp() async throws \{\
    batteryLevel = 100\
  \}\
  ...\
\}\
\
// After\
struct FoodTruckTests \{\
  var batteryLevel: NSNumber\
  init() async throws \{\
    batteryLevel = 100\
  \}\
  ...\
\}
\f1 \
\
XCTest is func testBlah() , while "the testing library" is @Test func blahblah(), so not name-driven any more.\
\
XCTest runs sync test methods on the main actor by default.  The Testing Library\'99 runs them on an arbitrary task.  Decorate with @MainActor if you need those semantics,\
\
or run the thread-sensitive code inside a call to MainActor.run(resultType:body:)\
\
instead of XCTAssertWhatever, use the #expect and #require macros.  They're\
like XCTAssert except require throws an error if the condition isn't met\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testEngineWorks() throws \{\
    let engine = FoodTruck.shared.engine\
    XCTAssertNotNil(engine.parts.first)\
    XCTAssertGreaterThan(engine.batteryLevel, 0)\
    try engine.start()\
    XCTAssertTrue(engine.isRunning)\
  \}\
  ....\
\}\
\
// After\
struct FoodTruckTests \{\
  @Test func engineWorks() throws \{\
    let engine = FoodTruck.shared.engine\
    try #require(engine.parts.first != nil)\
    #expect(engine.batteryLevel > 0)\
    try engine.start()\
    #expect(engine.isRunning)\
  \}\
  ...\
\}\

\f1 \
XCTUnwrap to test if an optional is nil and throw if it does.\
For The Testing Libary, use require with optional expressions to unwrap them\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testEngineWorks() throws \{\
    let engine = FoodTruck.shared.engine\
    let part = try XCTUnwrap(engine.parts.first)\
    ...\
  \}\
  ...\
\}\
// After\
struct FoodTruckTests \{\
  @Test func engineWorks() throws \{\
    let engine = FoodTruck.shared.engine\
    let part = try #require(engine.parts.first)\
    ...\
  \}\
  ...\
\}\

\f1 \
XCTFail to fail immediately and uncondionally - useful when syntax prevents the use of XCTAssert\
\
To do this, use record.\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testEngineWorks() \{\
    let engine = FoodTruck.shared.engine\
    guard case .electric = engine else \{\
      XCTFail("Engine is not electric")\
      return\
    \}\
    ...\
  \}\
  ...\
\}\
// After\
struct FoodTruckTests \{\
  @Test func engineWorks() \{\
    let engine = FoodTruck.shared.engine\
    guard case .electric = engine else \{\
      Issue.record("Engine is not electric")\
      return\
    \}\
    ...\
  \}\
  ...\
\}
\f1 \
\
And comparison table\
\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs34 \cf2 \expnd0\expndtw0\kerning0
XCTest
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2 \cf2 Swift Testing
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssert(x)
\f4 ,\'a0
\f5 XCTAssertTrue(x)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertFalse(x)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(!x)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertNil(x)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x == nil)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertNotNil(x)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x != nil)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertEqual(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x == y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertNotEqual(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x != y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertIdentical(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x === y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertNotIdentical(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x !== y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertGreaterThan(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x > y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertGreaterThanOrEqual(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x >= y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertLessThanOrEqual(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x <= y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertLessThan(x, y)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(x < y)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertThrowsError(try f())
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(throws: (any Error).self) \{ try f() \}
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertThrowsError(try f()) \{ error in \'85 \}
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect \{ try f() \} throws: \{ error in return \'85 \}
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTAssertNoThrow(try f())
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 #expect(throws: Never.self) \{ try f() \}
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 try XCTUnwrap(x)
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 try #require(x)
\f4 \cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trcbpat3 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth6996\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth7799\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadt141 \clpadl141 \clpadb141 \clpadr141 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 XCTFail("\'85")
\f4 \cell 
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f5 \cf2 Issue.record("\'85")
\f4 \cell \lastrow\row
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs36 \cf0 \kerning1\expnd0\expndtw0 \
XCTestCas has continueAfterFailure, set to false to cause the test to stop runing after a failure occurs. (by throwing an objc exception) which tears through a swift stack frame causing damage (especialky an async function)\
\
use require to throw a swift error that throws on failure. other tests will continue to run\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testTruck() async \{\
    continueAfterFailure = false\
    XCTAssertTrue(FoodTruck.shared.isLicensed)\
    ...\
  \}\
  ...\
\}\
// After\
struct FoodTruckTests \{\
  @Test func truck() throws \{\
    try #require(FoodTruck.shared.isLicensed)\
    ...\
  \}\
  ...\
\}
\f1 \
\
Validate async behaviors\
\
XCTEstExpectation / fulfilling expectaion, wait for it to be fulfilled\
\
Prefer to use Swift concurrency  to validate async conditions.\
\
if necessary to determine the result of an async swift function, can be awaited\
with await. With a completion handler, can use a swift continuation to convert the call into an async-compatible one.\
\
Some that can't be converted to use Swift concurrency, there's _confirmations_,\
created andu sed in teh scope of the function ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/confirmation"}}{\fldrslt https://developer.apple.com/documentation/testing/confirmation}})\
\
Confirmations don't block or suspend the caller while waiting for a condition to be fulfilled.  The requirement is expected to be _confirmed_ (equivalent of fulfilling an expectation) before conformation returns\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testTruckEvents() async \{\
    let soldFood = expectation(description: "\'85")\
    FoodTruck.shared.eventHandler = \{ event in\
      if case .soldFood = event \{\
        soldFood.fulfill()\
      \}\
    \}\
    await Customer().buy(.soup)\
    await fulfillment(of: [soldFood])\
    ...\
  \}\
  ...\
\}\
// After\
struct FoodTruckTests \{\
  @Test func truckEvents() async \{\
    await confirmation("\'85") \{ soldFood in\
      FoodTruck.shared.eventHandler = \{ event in\
        if case .soldFood = event \{\
          soldFood()\
        \}\
      \}\
      await Customer().buy(.soup)\
    \}\
    ...\
  \}\
  ...\
\}
\f1 \
\
XCTSkip error type can be thrown to bypass the remaineder of a test function.  Also XCTSkipIf and XCTSkipUnless\
\
Can use ConditionTrait trait type\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testArepasAreTasty() throws \{\
    try XCTSkipIf(CashRegister.isEmpty)\
    try XCTSkipUnless(FoodTruck.sells(.arepas))\
    ...\
  \}\
  ...\
\}\
// After\
@Suite(.disabled(if: CashRegister.isEmpty))\
struct FoodTruckTests \{\
  @Test(.enabled(if: FoodTruck.sells(.arepas)))\
  func arepasAreTasty() \{\
    ...\
  \}\
  ...\
\}\

\f1 \
Annotating known issues\
\
say a test has something that prevents it from passing.  With XCT, can do XCTExpectFailure\
\
The Testingt Library has equivalents: withKnownIssue(_:isIntermittent:[isolation]:sourceLocation:)\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testGrillWorks() async \{\
    XCTExpectFailure("Grill is out of fuel") \{\
      try FoodTruck.shared.grill.start()\
    \}\
    ...\
  \}\
  ...\
\}\
// After\
struct FoodTruckTests \{\
  @Test func grillWorks() async \{\
    withKnownIssue("Grill is out of fuel") \{\
      try FoodTruck.shared.grill.start()\
    \}\
    ...\
  \}\
  ...\
\}
\f1 \
\
XCTExpectFailure doesn't have a direct equivalent.  To mark a test as having a known issue, wrap its boyd with withKnownIssue\
\
XCTExpectFialure can be marked non0strict.  with testing lib, specify that the known issue is intermittent instead\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testGrillWorks() async \{\
    XCTExpectFailure(\
      "Grill may need fuel",\
      options: .nonStrict()\
    ) \{\
      try FoodTruck.shared.grill.start()\
    \}\
    ...\
  \}\
  ...\
\}\
\
// After\
struct FoodTruckTests \{\
  @Test func grillWorks() async \{\
    withKnownIssue(\
      "Grill may need fuel", \
      isIntermittent: true\
    ) \{\
      try FoodTruck.shared.grill.start()\
    \}\
    ...\
  \}\
  ...\
\}
\f1 \
\
Also withKnownIssues that take additional arguments with behavior\
* {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:)"}}{\fldrslt https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:)}}\
* {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)"}}{\fldrslt https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)}}\
* {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:when:matching:)"}}{\fldrslt https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:when:matching:)}}\
* {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:when:matching:)"}}{\fldrslt https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:when:matching:)}}\
\

\f2 // Before\
class FoodTruckTests: XCTestCase \{\
  func testGrillWorks() async \{\
    let options = XCTExpectedFailure.Options()\
    options.isEnabled = FoodTruck.shared.hasGrill\
    options.issueMatcher = \{ issue in\
      issue.type == thrownError\
    \}\
    XCTExpectFailure(\
      "Grill is out of fuel",\
      options: options\
    ) \{\
      try FoodTruck.shared.grill.start()\
    \}\
    ...\
  \}\
  ...\
\}\
\
// After\
struct FoodTruckTests \{\
  @Test func grillWorks() async \{\
    withKnownIssue("Grill is out of fuel") \{\
      try FoodTruck.shared.grill.start()\
    \} when: \{\
      FoodTruck.shared.hasGrill\
    \} matching: \{ issue in\
      issue.error != nil \
    \}\
    ...\
  \}\
  ...\
\}
\f1 \
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/known-issues"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/known-issues}}\
\
Highlight known issues when running tests.\
\
use withKnownIssue() (and variants) to mark issues as known.  Informs the testing library at runtime not to mark the tests as failing when issues occur\
\
Describe failure or warning via an Issue\
\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f0\b \cf0 (Grate) Expectataions and Confirmations, also by Edmund Welles\

\f1\b0 \
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/expectations"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/expectations}}\
\
check for expected values, outcomes, and async events in tests\
\
Use expect(_:_:_:_:_:_:_:_:sourceLocation:) and require(_:_:sourceLocaton) macros (wheee) to validate expected outcomes.\
\
To validate an error is (not) thrown, it provides overloads of the macros.\
\
C.f. TESTING FOR ERRORS  {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code"}}{\fldrslt https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code}}\
\
Use a Confirmation ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/confirmation"}}{\fldrslt https://developer.apple.com/documentation/testing/confirmation}}) to confthe occurence of an async event.  \
C.f. Testing AsyncCode ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/testing-asynchronous-code"}}{\fldrslt https://developer.apple.com/documentation/testing/testing-asynchronous-code}})\
\
Validating code's result - use expect.\
\
The macro captures the expression passed in, and provides detailed info when the code doesn't statisfy the expecation\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 @Test func calculatingOrderTotal() \{\
  let calculator = OrderCalculator()\
  #expect(calculator.total(of: [3, 3]) == 7)\
  // Prints "Expectation failed: (calculator.total(of: [3, 3]) \uc0\u8594  6) == 7"\
\}\

\f1 Tests keep running after the expect fails.\
\
To stop the test, use require\
\

\f2 @Test func returningCustomerRemembersUsualOrder() throws \{\
  let customer = try #require(Customer(id: 123))\
  // The test runner doesn't reach this line if the customer is nil.\
  #expect(customer.usualOrder.countOfItems == 2)\
\}\

\f1 \
require throws an instance of ExpectationFailedError when it fails\
\
lots o' flavors.\
EXPERIMENT TO DO:\
	- try to do each of the expects and requires on {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/expectations"}}{\fldrslt https://developer.apple.com/documentation/testing/expectations}}\
	- same with {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code"}}{\fldrslt https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code}}\
\
\
Testing for errors \
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code}}\
\
ensure your code handles errors in the way you expect.\
\
Write test that valid the conditions in which the code throws errors and conditions in which it returns without throwing an error.\
\
use overloads of expect/require to check for errors\
\
Validate your code throws an expected erorr\
\
Make a test function that throws and try the code under test. If the code throws an error, then your test fails.\
\
To check that the code under test throws a specific error, or continue a longer test function after it throws, pass the error as the first argument of expect(throws:...) and pass a closure that calls the code under test\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 @Test func cannotAddToppingToPizzaBeforeStartOfList() \{\
  var order = PizzaToppings(bases: [.calzone, .deepCrust])\
  #expect(throws: PizzaToppings.Error.outOfRange) \{\
    try order.add(topping: .mozarella, toPizzasIn: -1..<0)\
  \}\
\}
\f1 \
\
If the closure completes without throwing an error,  it records an issue\
Other overloads of expect let you test the code throws an error of a given type, or matches an arbitrary Boolean test.\
\
Similar overloads of require stop running the test.\
\
Validate it doesn't throw an error\
\
a test function that throws an error means that it fails , usually sufficient for testing that code doesn't throw.\
\
if need to record a thrown error as an issue without stopping the test, compare the error to Never\
\

\f2 @Test func canAddToppingToPizzaInPositionZero() throws \{\
  var order = PizzaToppings(bases: [.thinCrust, .thinCrust])\
  #expect(throws: Never.self) \{\
    try order.add(topping: .caper, toPizzasIn: 0..<1)\
  \}\
  let toppings = try order.toppings(forPizzaAt: 0)\
  #expect(toppings == [.caper])\
\}
\f1 \
\

\f0\b Testing Async Code\

\f1\b0 \
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/testing-asynchronous-code"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/testing-asynchronous-code}}\
\
Validate your code causes expected events to happen\
\
The Testing Library integrates with Swift Concurrency.  So can test async code using standard swift features.   Mark test as async, then in the body await any async interactions\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 @Test func priceLookupYieldsExpectedValue() async \{\
  let mozarellaPrice = await unitPrice(for: .mozarella)\
  #expect(mozarellaPrice == 3)\
\}
\f1 \
\
In more complex situations can use Confirmation ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/confirmationhttps://developer.apple.com/documentation/testing/confirmation"}}{\fldrslt https://developer.apple.com/documentation/testing/confirmationhttps://developer.apple.com/documentation/testing/confirmation}})  to discover whether an expected event happens\
\
Call confirmation(_:expectedCount:isolation:sourceLocation:_:) to create a Confirmation to for the expected event.  In the trailing closure parameter, call the code under test.\
The Test Library passes a Confirmation as the parameter to the closure.  Call as afunction in the event handler for the code under test when the event testing for occurs.\
\

\f2 @Test("OrderCalculator successfully calculates subtotal for no pizzas")\
func subtotalForNoPizzas() async \{\
  let calculator = OrderCalculator()\
  await confirmation() \{ confirmation in\
    calculator.successHandler = \{ _ in confirmation() \}\
    _ = await calculator.subtotal(for: PizzaToppings(bases: []))\
  \}\
\}
\f1 \
\
(note not #confirmation - the mix of #blah and non-# blah is kind of confusing)\
\
Set the expectedCount parameter to the number of times you expect the confirmation to be called.  Test passes if the number of occurences during the tst matches the expected count, before falling off the bottom of the crosure.\
\
Confirming an event does _not_ happen - create a confirmation with an expected count of zero\
\

\f2 @Test func orderCalculatorEncountersNoErrors() async \{\
  let calculator = OrderCalculator()\
  await confirmation(expectedCount: 0) \{ confirmation in\
    calculator.errorHandler = \{ _ in confirmation() \}\
    calculator.subtotal(for: PizzaToppings(bases: []))\
  \}\
\}
\f1 \
\
\

\f0\b Parameterized Tests
\f1\b0 \
\
Some tests need to be run over many different inputs. - might need to validate all cases in an enum.  TTL lets us specify one or more collections to iterate over during testing, with the elements being forward to a test function.\
\
An invocation of the test function with a particular set of argument values is a _test case_\
\
A group of test functions is a _basket case_\
\
By default they run in parallel with each other. Saw earlier how to run them serially\
\
over an array of values \
\

\f2 enum Food \{\
  case burger, iceCream, burrito, noodleBowl, kebab\
\}\
\
@Test("All foods available", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])\
func foodAvailable(_ food: Food) async throws \{\
  let foodTruck = FoodTruck(selling: food)\
  #expect(await foodTruck.cook(food))\
\}\

\f1 \
when passing a collection to @Test, the library passes each element of the collection, one at a time,. to the test function a its first (and only) argument.  If it fails for one or more inputs, the diagnostics clearly indicate which inputs to examine\
\
over the cases of an enumeration - pass the EnumType.allCases (and of course need CaseIterable)\
\
Going over a range of integers, can pass it a closed range.\
\

\f2 @Test("Can make large orders", arguments: 1 ... 100)
\f1 \
\
heh.  "Note, very large ranges like 0 ..< .max may take an excessive amount of time to test or may never complete"  - "please don't spray windex into eyes"\
\
Any collection that's Sendable - Array / Set / OptionSet / Dictionary / Range\
\
More than one collection (cartesian product). so say 5 fuds, this will be run FIVE HUNDRED times. \
\

\f2 @Test("Can make large orders", arguments: Food.allCases, 1 ... 100)\
func makeLargeOrder(of food: Food, count: Int) async throws \{\
  let foodTruck = FoodTruck(selling: food)\
  #expect(await foodTruck.cook(food, quantity: count))\
\}\

\f1 \
To avoid the combinatorial asplosion, use zip\
\
oh, and a maximum of two collections when not using zip\
\

\f2 @Test("Can make large orders", arguments: zip(Food.allCases, 1 ... 100))\

\f1 \
The zip sequence will be "destructured" into two arguments automagically. so like (.burger, 1), (.miceCream, 2), etc\
\
Running selected test cases. - allows you to run specific test cases it contains - like if there's :alot: of cases, but only some are failing.\
\
It must be deterministically match the test case's arguments.  When someone attepmts to run selectected test cases (how?) of a parameterized test function, TTL evaluates each argument of the test's cases for conformance to one of several known protocols.  if all arguments CONFORM, the test can be run selectively.\
 	- CustomTestArgumentEncodable ({\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/customtestargumentencodable"}}{\fldrslt https://developer.apple.com/documentation/testing/customtestargumentencodable}}) - for types that don't conform to Encodable or Decodable\
	- Raw Representable where RawValue conforms to Encodable\
	- Encodable\
	- Identifiable where ID conforms to Encodable\
(sounds like the selective test running depends on the parameter being Encodable.\
\
\

\f0\b Traits
\f1\b0 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/traits"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/traits}} \
Add traits to tests to annotate them or customize their behavior\
\
Pass built-in traits to test functions or suite types to comment, categorize, and modify runtime behaviors.  (so kind of the SwiftUI approach of "hey here's a bunch of different stuff stuff that all hangs off the same basic model)\
\
Can use the Trait, TestTrait, and SuiteTrait protocols to create own types that customize the behavior of test functions\
\
topics:\
	- enabling and disabling tests\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/enablinganddisabling"}}{\fldrslt https://developer.apple.com/documentation/testing/enablinganddisabling}}\
	- limiting running time\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/limitingexecutiontime"}}{\fldrslt https://developer.apple.com/documentation/testing/limitingexecutiontime}}\
	- adding tags to tests\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/addingtags"}}{\fldrslt https://developer.apple.com/documentation/testing/addingtags}}\
	- adding comments\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/addingcomments"}}{\fldrslt https://developer.apple.com/documentation/testing/addingcomments}}\
	- associating bugs with tests\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/associatingbugs"}}{\fldrslt https://developer.apple.com/documentation/testing/associatingbugs}}\
	- interpetting bug identifiers\
		- {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/bugidentifiers"}}{\fldrslt https://developer.apple.com/documentation/testing/bugidentifiers}}\
\
And more types:\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 	- Bug\
	- Comment\
	- ConditionTrait\
	- ParallelizationTrait\
	- Tag\
	- List\
	- TimeLimitTrait\
\
(the rabbit hole just keeps going deeper and deeper)\
\
\
Enalbing and disabling tests\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/enablinganddisabling"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/enablinganddisabling}}\
\
sometimes a test is only applicable in specific circumstances - might want it to run on devices with particular hardware, or locale-dependent operations.  Can add traits to the tests that cause runners to automatically skip them if conditions are not met.\
\
Note: Condition may be evaluated multiple times during testing. 
\f6\i (not sure why they decided to call that out)
\f1\i0 \
\
To disable unconditionally, use disabled function\
\
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f2 \cf0 @Test("Food truck sells burritos", .disabled())\
func sellsBurritos() async throws \{ ... \}\

\f1 \
test will now always be skipped.\
\
Can also give an optional comment.\
\
enable or disable test conditionally - .enabled(if:)\
\

\f2 @Test("Ice cream is cold", .enabled(if: Season.current == .summer))\
func isCold() async throws \{ ... \}\

\f1 \
can have multiple conditions (so the @Test is very variadic). They all have to pass (or be no-ops)  Otherwise the runner notes the first condition to fail as the reason the test is skipped.\
\

\f2 @Test(\
  "Ice cream is cold",\
  .enabled(if: Season.current == .summer),\
  .disabled("We ran out of sprinkles")\
)\
func isCold() async throws \{ ... \}\

\f1 \
If it's due to a bug, can use the bug trait\

\f2 @Test(\
  "Ice cream is cold",\
  .enabled(if: Season.current == .summer),\
  .disabled("We ran out of sprinkles"),\
  .bug(id: "12345")\
)\
func isCold() async throws \{ ... \}\

\f1 \
Can call functions in the test conditions to factor out complex logic\
\

\f2 func allIngredientsAvailable(for food: Food) -> Bool \{ ... \}\
\

\f1 @Test(
\f2 \
  "Can make sundaes",\
  .enabled(if: Season.current == .summer),\
  .enabled(if: allIngredientsAvailable(for: .sundae))\
)\
func makeSundae() async throws \{ ... \}\

\f1 \

\f0\b Limiting Runtime
\f1\b0 \
\pard\pardeftab720\partightenfactor0
\cf0  {\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/limitingexecutiontime"}}{\fldrslt https://developer.apple.com/documentation/testing/limitingexecutiontime}}\
\
use timeLimit trait.  Multiple limits use the shortest one. defaults to one minute (and is configurable)\
\

\f2 @Test(.timeLimit(.minutes(60))\
func serve100CustomersInOneHour() async \{\
  for _ in 0 ..< 100 \{\
    let customer = await Customer.next()\
    await customer.order()\
    ...\
  \}\
\}
\f1 \
(a 60 minute test? wtf...)\
\
if the time limit runs out, the task that's running is cancelled, and test fails with a timeLimitExceeded issue\
\
Can apply to test suites - recursively applied to all test functions and child test suites (sounds like then the time isn't for the entire suite, just bubbled down to the test functions.\
\
Time limits on parameterized tests are applied to each invocation seperately. That way if one blorfs, then it won't incorrectly mark others as being blorfed\
\

\f0\b Adding tags to tests\
\

\f1\b0 use tags to provide semantic information for organization, filtering, and customizing appearances. \
\
a complex package may contain hundreds or thousands of tets and suites. Some may share a common facet, like being 
\f0\b critical
\f1\b0  or 
\f0\b flaky
\f1\b0 .  can use tags to add to the group and categorize tests.\
\
Tags != test suites - suites impose structure on test functions on a source leve.  Tags provide semantic information for a test that can be shared with any number of other tests across test suites, source files, or even test targets 
\f6\i (how is that expressed?)\

\f1\i0 \
To add a tag, use the tags trait. - takes a sequence of tags as its argument, and those are applied to the test at runtime.\
\
if any tags are applied to a test suite, then all tests inherit those tags.\
\
TTL doesn't assign any semantic meaning to any tags, nor does it affect how the testing library runs tests.\
\
Tags are instances of Tag and expressed as named constants.  Use the Tag macro:\
\

\f2 extension Tag \{\
  @Tag static var legallyRequired: Self\
\}\
\
\
@Test("Vendor's license is valid", .tags(.legallyRequired))\
func licenseValid() \{ ... \}
\f1 \
\
If two tags with the same name are declared in differnt files/modules/othercontext, TTL treats them as equivalent\
\
If it's important to disambiguate, use reverse-DNS naming\
\

\f2 extension Tag \{\
  enum com_example_foodtruck \{\}\
\}\
\
extension Tag.com_example_foodtruck \{\
  @Tag static var extraSpecial: Tag\
\}\
\
@Test(\
  "Extra Special Sauce recipe is secret",\
  .tags(.com_example_foodtruck.extraSpecial)\
)\
func secretSauce() \{ ... \}\

\f1 \
Tags must always be declared as a member of Tag in an extension (or in a nested type)\
\
\pard\pardeftab720\partightenfactor0

\f6\i \cf0 (and how are those tags used?)\
\pard\pardeftab720\partightenfactor0

\f1\i0 \cf0 \

\f0\b Adding comments to tests
\f1\b0 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/addingcomments"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/addingcomments}}\
\
- provide context or background info about code's urpose\
- explain how complex code implemented [sic]\
- includes details which may be helpful when diagnosing issues\
\
Comments can be added to test declrations and TTL will automatically capture and show them when issues are recorded\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 // Assumes the standard lunch menu includes a taco\
@Test func lunchMenu() \{\
  let foodTruck = FoodTruck(\
    menu: .lunch,\
    ingredients: [.tortillas, .cheese]\
  )\
  #expect(foodTruck.menu.contains \{ $0 is Taco \})\
\}
\f1 \
\
Comments on tests are most useful when they\
- add information not obvious from reading the code\
- provide useful information about the operation or motivation of the test\
\
if test is related to a bug or issue, consider using the Bug trait instead.\
\

\f0\b Associating bugs with tests\
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/associatingbugs"}}{\fldrslt 
\f1\b0 \cf0 https://developer.apple.com/documentation/testing/associatingbugs}}
\f1\b0 \
\
"bugs" can be referred to as "Issues" IRL,there is an Issue type in TTL, so the link refers to them all as Bugs\
\
Three forms\
	 - url representing the bug\
	- unique identifier (string) (with or without url)\
	- unique identifier (numeric) (with or without url)\
\
\pard\pardeftab720\partightenfactor0

\f2 \cf0 @Test("Food truck engine works", .bug("https://www.example.com/issues/12345"))\
func engineWorks() async \{\
  var foodTruck = FoodTruck()\
  await foodTruck.engine.start()\
  #expect(foodTruck.engine.isRunning)\
\}
\f1 \
\
Can also add a title.\
\

\f2 @Test(\
  "Food truck has napkins",\
  .bug(id: "12345", "Forgot to buy more napkins")\
)\
func hasNapkins() async \{\
  ...\
\}
\f1 \
\

\f0\b Interpreting bug identifiers
\f1\b0 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://developer.apple.com/documentation/testing/bugidentifiers"}}{\fldrslt \cf0 https://developer.apple.com/documentation/testing/bugidentifiers}}\
\
how TTL interprets bug identifiers\
\
Two ways to identify a bug:\
	- url linking to more info\
	- unique ID (string/id)\
	- or both\
\
It will infer bug tracking systems (github issues, webkit bugzilla, apple Feedbackdar black hole)\
\
\pard\pardeftab720\qc\partightenfactor0
\cf0 \ul \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\ulnone \
\pard\pardeftab720\partightenfactor0
\cf0 Now for the wwdc vids.\
\
10195-Go further with Swift Testing\
\
Not transcribing, just interesting notes\
\
challenges\
	- redability - easy to ead and understand\
	- coverage\
	- organizing\
	- hidden dependencies make them fragile\
\
Expressive cod\
	- expectations - expect macro is more sophisticated\
		- expectThrows - catch and examine error.  rather than writing the do / catch / etc\
		- #expect(throws: (any Error).self) \{ try ... \}\
can also do more sophisticated via #expect throws macro\
\

\f2 @Test func brewTea() \{\
	let teaLaves = ...\
	#expect \{\
		try teaLeaves.brew(forMinutes: 3)\
	\} throws: \{ error in\
		guard let error = error as? BewingError,\
			case let .needsMoreTime(optimalBewTime) = error else \{\
			return false\
		\}\
		return optionalBewTime == 4\
	\}\
\}
\f1 \
\
Don't disable tests, but use withKnownIssue - it'll continue complaining, but won't show up as failing. Then when it works, withKnownIssue will then fail so you know to remove it\
\
Test descriptions (vs production code)\
\
CONFORM to CustomTestStringConvertable, and provide a var testDescription: String \{\}\
\

\f2 struct SoftServe: CustomTestStringConvertible \{\
	var testDescription: String \{\
		"\\(flavor) in a \\(container)"\
	\}\
\}\

\f1 \
parameterized tests\
	- since run in parallel, will run faster than a for loop\
	test cases displayed in test navigator and test report\
\
organizing tests\
	- suites\
	- document with names\
	- suites can contain other suites\
	- can add subsuites and show organizing the tests themselves\
	- tags.  (like caffeniated vs chocolate foods, beacuse some can be both)\
		- not a replacement for suites\
		- suites impose structure at the source level\
		- tags associate tests from different files/suites/targets that share something\
		need @Tag before the static var caffeinented: Self (without assignemnt)\
	- test navigator lets group by tags\
	- filter matches function and tag names, tag filters\
	- organize by tags with search field dingus\
test plan editor can be driven by tag\
	- list of test plans in the test navigator (~17:00)\
		- can include and exclude tags. tags excluded are crossed out.\
		- multiple tags is AND / OR\
	- tags for anayzing results\
		- pie chart.  lots of failures\
		- tags appear in the outline.\
		- there's a tags filter\
		- insights screen - shows patterns in test failures\
			- double click on the row\
ignoring xcode cloud\
\
parallel testing enabled by default.  Even across parallel devices\
order is randomized  - surface hidden dependencies between tests\
\
.serialized can be added to indicate will run serially. lose the advantages, so should fix it.\
also to a parameteried function\
\
waiting on async conditions\
	- await works the same way\
	- @24:48 - don't understand. Objc with a completion handler\
		- "swift provides an async overload that does that automatically"\
\
original: "runs after the test function returns" (the eat(cookies...) part)\

\f2 @Test func bakeCookies () async throws \{\
	let cookies = await Cookie.bake(count: 10)\
	eat (cookies, with: .milk) \{ result, error in\
		#expect(result != nil)\
	\}\
\}\

\f1 \
"automatic":\
\

\f2 @Test func bakeCookies() async throws \{\
	let cookies = await Cookie.bake(count: 10)\
	try await eat(cookies, with: .milk)\
\}\

\f1 \
can do withChecked[Throwing]Continuation\
\
event handlers that might call more than once.  Counting manually has data race issues\
use confirmation\
\
\
}