{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs36 \cf0 ## Arrays\
\
In many performance-oriented languages, arrays have a particular implemention that makes them very fast for what they do.\
\
- large contiguous chunk of memory\
- uniform size of entities\
\
This allows easy "pointer plus scaled offset" for indexing.  If you know your array items are 30 bytes long, you can figure out the address in memory for the N'th item by doing baseAddress + N * 30.  makes random access really fast\
\
And because arrays are in a contiguous chunka bytes, iterative scanning through them (for i in 0 .. size; do stuff with array[i]) take advantage of the processor's prefetching behavior.\
\
SO, knowing that, things like   func blah(array: [any Greeble]) - my brain went into vapor-lock.  Greebles can be enums, or structs, or classes.  all different sizes. HOW CAN THAT WORK?!??!\
\
\
\
}