{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs36 \cf0 ## More than a copy\
\
So, class instances need to be retained when used, and released when done with.  If I pass an object to a function, it gets retained on the way in (reference count incremented), and released (reference count decremented) on the way out. \
\
if I assign an object to a local property, it gets retained when assigned, and then if a new value is assigned, the original is released.\
\
When the reference count hits zero, the memory is freed.  Notice memory is freed, so that implies that the object has been allocated.  You can think of objects living in the heap.  Structures can live anywhere their inline representation can live.  So a structure can be passed on the C stack without involving expensive dynamic memory.\
\
So, what if a struct contains references to objects? Those need to be retained and released\
\
(struct-class.swift)\
\
\
}