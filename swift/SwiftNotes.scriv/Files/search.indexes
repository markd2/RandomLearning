<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="5641A8C0-884F-4C39-9C47-EB7BFACB73F1">
            <Title>Swift Under the Hood</Title>
            <Text># Swift under the hood

Things like in-memory representation, existential containers, witness tables, etc.

Big caveat - don't use this information to make decisions, unless you know you should use this information to make decisions.

"you should have an intuition for what performance different language features give you"

I know for me, I get all sorts of "oh, so that's how $SOMETHING works" hits of dopamine with these things (as we'll see with arrays)
</Text>
        </Document>
        <Document ID="C1DD02B5-E104-40F2-B910-750B9D444DB6">
            <Title>csh time builtin output format</Title>
            <Text>%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww

%U
The time the process spent in user mode in cpu seconds.

%S
The time the process spent in kernel mode in cpu seconds.

%E
The elapsed (wall clock) time in seconds.

%P
The CPU percentage computed as (%U + %S) / %E.


%X
The average amount in (shared) text space used in Kbytes.
%D
The average amount in (unshared) data/stack space used in Kbytes.

%I
The number of input operations.
%O
The number of output operations.

%F
The number of major page faults (page needed to be brought from disk).
%W
Number of times the process was swapped.

</Text>
        </Document>
        <Document ID="DDA87D8C-29B8-462D-9839-BA2FEBC09AC4">
            <Title>Benchmarking</Title>
            <Text>## Benchmarking

I was going to do some really cheesy benchmarking but ran out of time.

But folks might not realize the disparity between Swift's performance in debug and release mode.

Make sure you're optimizing if you're doing any kind of real comparisons.  Unoptimized Swift is a porker.

for example

test-opt.swift

let n = 10000
var x = [Int](repeating: 1, count: n)

for i in 0 ..&lt; n {
    for j in 0 ..&lt; n {
        x[i] ^= x[j] &lt;&lt; (i+j) % 16
    }
}
print("blah: \(x[0])")

% swiftc    test-opt.swift -o tg
% swiftc -O test-opt.swift -o to


% time ./to
blah: 14
0.252u 0.002s 0:00.25 100.0%    0+0k 0+0io 4pf+0w

while tg is running, explain the output of time

% time ./tg
blah: 14
26.189u 0.018s 0:26.50 98.8%    0+0k 0+0io 13pf+0w


So like two orders of magnitude faster - 26 seconds for "only" 100,000,000 bits of work is not fast.  Sometimes this is really noticeable with the swift algorithms, like doing a permutation over a set.
</Text>
        </Document>
        <Document ID="0C1844CA-6BF0-4F68-89F8-992892F47349">
            <Title>Quick Reference</Title>
        </Document>
        <Document ID="EAAE4896-FE10-41C8-B75B-D849D5D4837F">
            <Title>Protocols</Title>
            <Text>## Protocols

One of swift's defining features is its ability to add layers of abstraction and polymorphism via protocols.  A protocol describes some subset of functionality (say "codable" or "human biometric provider") 

So revisit layout.swift

protocol Snorgle {
    var anInt: Int { get }
/*
    var aBool: Bool { get }
    var anotherInt: Int { get }
    var anotherBool: Bool { get }
    var short: Int16 { get }

    func x()
    func y()
    func z()
    func q()
*/
}

extension Thing1: Snorgle {
    func x() {}
    func y() {}
    func z() {}
    func q() {}
}

extension Thing2: Snorgle {
    func x() {}
    func y() {}
    func z() {}
    func q() {}
}
and run, and get

Snorgle
  size: 40
  stride: 40
  alignment: 8
  anInt offset: -1
  aBool offset: -1

if you throw more things in to it, the thing doesn't get any bigger.

The alignment of 8 implies that there's a data type that requires 8-byte alignment, so probably pointers involved.  size of 40 would mean five pointers.

"Any problem can be solved with an additional layer of indirection"



</Text>
        </Document>
        <Document ID="BA1108B6-D88C-4C58-9629-189F748F2CFE">
            <Title>More than a copy</Title>
            <Text>## More than a copy

So, class instances need to be retained when used, and released when done with.  If I pass an object to a function, it gets retained on the way in (reference count incremented), and released (reference count decremented) on the way out. 

if I assign an object to a local property, it gets retained when assigned, and then if a new value is assigned, the original is released.

When the reference count hits zero, the memory is freed.  Notice memory is freed, so that implies that the object has been allocated.  You can think of objects living in the heap.  Structures can live anywhere their inline representation can live.  So a structure can be passed on the C stack without involving expensive dynamic memory.

So, what if a struct contains references to objects? Those need to be retained and released

(struct-class.swift)


</Text>
        </Document>
        <Document ID="AE8BCB40-8CD3-44E9-A029-EFDBFB897DD4">
            <Title>Existential Containers</Title>
            <Text>## Existential Containers

one pointer for the witness table
three word-size for inline-storage, otherwise flow out to dynamic memory (based on scoping)
and not sure what the other word is for

</Text>
        </Document>
        <Document ID="3E912E40-69F9-4FEA-9F22-42C186FD7171">
            <Title>Quick Reference</Title>
            <Text>Always skip tests
@Test("Food truck sells burritos", .disabled("optional comment"))
func sellsBurritos() async throws { ... }

Require non-nil result / unwrap for rest of test
let customer = try #require(Customer(id: 123))
If you forget the try, you'll get an error that has no error marker in the editor #ilyxc

Don't kill the test if something throws
#expect(throws: Never.self) { // if it throws, record an error, but don't kill the test
  try order.add(topping: .caper, toPizzasIn: 0..&lt;1)
}

Expecting a particular error
#expect(throws: (any Error).self) { try ... } // or an error type

Conditionally enable a test
@Test("Ice cream is cold", .enabled(if: Season.current == .summer))
func isCold() async throws { ... }

Chaining multiple conditions
@Test(
  "Ice cream is cold",
  .enabled(if: Season.current == .summer),
  .disabled("We ran out of sprinkles")
)
func isCold() async throws { ... }

Adding a bug ID
@Test(
  "Ice cream is cold",
  .bug(id: "12345")
)
func isCold() async throws { ... }

Limit test running
@Test(.timeLimit(.minutes(60))

Attach a bug id (can also include a url)
@Test(
  "Food truck has napkins",
  .bug(id: "12345 or numeric value", "optional description")
)
func hasNapkins() async {

Making a custom description for test output
struct SoftServe: CustomTestStringConvertible {
	var testDescription: String {
		"\(flavor) in a \(container)"
	}
}

Iterative tests
@Test(arguments: 0 ..&lt; 10)
func createBubbleChoosesID(count: Int) {

Are we running in tests? (not 100% sure this is the best way. Only tested on Mac so far)
let inTests = ProcessInfo().environment["XCTestBundlePath"] != nil
if !inTests {        

Serializing tests (handy during debugging argument tests)
@Test(.serialized) func blah() {


sdjfnsdjf



</Text>
        </Document>
        <Document ID="C341F091-E04B-4D12-B18F-6685DA0A50E7">
            <Title>xcrud 15 vs 16</Title>
            <Text>IIRC built into xc16. for 15, you need some hoops

</Text>
        </Document>
        <Document ID="4D3CF17A-C9DB-4703-864D-115FCC3E8777">
            <Title>Bucket of Notes</Title>
            <Text>Swift Testing

New and improved testing frameworkke

                                                                                                    

https://developer.apple.com/xcode/swift-testing/

Clear Expressive API

* declare complex behaviors with a small amount of code
* #expect uses Swift expressions and operators
	- captures evaluated values so can quickly understand what went wrong
* Parameterized tests run the same test over a sequence of values
* integrate seamlessly with Swift Concurrency and run in parallel by default

@Test("Continents mentioned in videos", arguments: [
    "A Beach",
    "By the Lake",
    "Camping in the Woods"
])
func mentionedContinents(videoName: String) async throws {
    let videoLibrary = try await VideoLibrary()
    let video = try #require(await videoLibrary.video(named: videoName))
    #expect(video.mentionedContinents.count &lt;= 3)
}

Custom test behaviors

Can customize behavior of test/suites using traits.
Can describe the runtime conditions for a test
	- which device a test should ruin on
	- limt test to a certain OS system versions
	- help in CI by specifying execution time limits

@Test(.enabled(if: AppFeatures.isCommentingEnabled))
func videoCommenting() async throws {
    let video = try #require(await videoLibrary.video(named: "A Beach"))
    #expect(video.comments.contains("So picturesque!"))
}

Easy and Flexible Organization

Provides many ways to keep your tests organized.
	- structure related tests using a hierarchy of groups and subgroups
	- apply tags to flexibly manage, edit, and run tests with common characteristics across your test suite
	- also give tests a descriptive name

@Test("Check video metadata",
      .tags(.metadata))
func videoMetadata() {
    let video = Video(fileName: "By the Lake.mov")
    let expectedMetadata = Metadata(duration: .seconds(90))
    #expect(video.metadata == expectedMetadata)
}

Tooling

work with tests and suites inside of xcrud
inline presentations of tst results
re-run specific arguments for parameterized tests for debugging

run from the command line using SPM (yay!)

Open Source / Cross Platform

works on all major platforms.
Tests can behave more consistently when moving between platforms.
open source

works with XCTest

can run side-by-side with newer SwiftTesting

                                                                                                    

https://developer.apple.com/documentation/testing/

intro blurb
Develop tests with more confidence and less code
integrates seamlessly with SPM testing workflow
customizable metadata
scalable test execution

- define test functions almost anywhere with a single attribute
- group related tests into hierarchies using Swift's type system
- integrate seamlessly with Swift Concurrency
- Parameterize test functions
- enable tests dynamically depending on runtime conditions
	- hopefully there's a phase of moon attribute
- paralleize tests in-process
- categorize tests using tags
- associate bugs directly with the tests that verify their fixes or repro their problems
	- interesting

Defining Test Functions

https://developer.apple.com/documentation/testing/definingtests

"definite a test function to validate that code is working correctly:

Article assumes the package or project has already been configured with a test target (c.f. https://developer.apple.com/documentation/Xcode/test-coverage)

import Testing

Note:
	- Only import the testing liberry into a test target
	- importing into an application, libary, or binary target isn't supported / recommended
	- test functions aren't stripped from binaries when building for release, so all sorts of stuff could be visible

Declaring a test function

@Test func foodTruckExists() {
    // test logic goes here
}

can be at file-scope or inside a type

A type containing test functions is automatically a test suite.  c.f. https://developer.apple.com/documentation/testing/organizingtests

The above function doesn't do much.  Add expectations to the test function. c.f. Edmund Welles https://developer.apple.com/documentation/testing/expectations

Can customize the test name's (so when it's surfaced in an IDE or command line" - can add a string literal to the @Test attribute

@Test("Food truck exists") func foodTruckExists() { ... }

To further customize appearance and behavior of a test function, use traits like tags(_:)

concurrent or throwing tests

can decorate the test with async / throws / @MainActor

limiting availability

For running on newer versions of OS or language, use @available.  e.g.
	@available(swift, introduced: 8.0, message: "Requires Swift 8.0 features to run")

and can also use @available for things like an OS gate (@available(macOS 11.0, *))

There's also migrating a test from XCTest, via https://developer.apple.com/documentation/testing/migratingfromxctest

Test Suite Types

https://developer.apple.com/documentation/testing/organizingtests

When working with a large chunk of functions, helpful to organize them into test suites.

Two ways
- placing it into a Swift type
- placing it in a swift type and annotating that type with the @Suite attributt

@Suite isn't required to recognize a type contains test functions.  Does allow customization of the test's appearance in tooling.  Traits like tags/disabled are inherited by the test in the suite

Can have nested test suites

tests within a suite run in parallel. c.f. https://developer.apple.com/documentation/testing/parallelization

customizing name

@Suite("Food truck tests") struct FoodTruckTests {
  @Test func foodTruckExists() { ... }
}

test functions in a test suite type

instance method test functions, the library calls that by initialziing an instance of the type, then calling the test function

So these two are equivalent

@Suite struct FoodTruckTests {
  @Test func foodTruckExists() { ... }
}

@Suite struct FoodTruckTests {
  func foodTruckExists() { ... }


  @Test static func staticFoodTruckExists() {
    let instance = FoodTruckTests()
    instance.foodTruckExists()
  }
}

limitations / constraints on suite types

an initializer may be required
	- may be implicit or explicit
	- sync or async
	- throwing or non-thorwing
	- private/fileprivate / internal / package / public

Test suite types must always be available - not annotated with @available


https://developer.apple.com/documentation/testing/parallelization
Running tests serially or in parallel

testing library uses task groups, and tests all run in the same process.

number of tests that run concurrently s controlled by the runtime

parallelization can be disabled on a per-function or a per-suite basis using serialized

@Test(.serialized, arguments: Food.allCases) func prepare(food: Food) {
  // This function will be invoked serially, once per food, because it has the
  // .serialized trait.
}


@Suite(.serialized) struct FoodTruckTests {
  @Test(arguments: Condiment.allCases) func refill(condiment: Condiment) {
    // This function will be invoked serially, once per condiment, because the
    // containing suite has the .serialized trait.
  }


  @Test func startEngine() async throws {
    // This function will not run while refill(condiment:) is running. One test
    // must end before the other will start.
  }
}

when added to a parameterized test function, serialized causes that test to run its cases serially instead of paralle.

When applied to a non-param test function, has no effect

When applied to a test suite, causes it to run the contained test functions and sub-suites serially

Recursively applied through embedded suites

doesn't affect execution of a test relative to its peers or unrelated tests.

has no effect if parallelization is globally disabled (e.g. --no-parallel to swift test)

Migrating from XCTest

https://developer.apple.com/documentation/testing/migratingfromxctest

Can coexist in the same file

XCTest groups related sets of test methods in test calsses inheriting from XCTestCase.
Can be free or global, or static or class members of a type.

To convert XCTestCase to a suite, remove the XCTestCase CONFORMance.

Swift structure or actor be used to better enforce concurrency saftey

// Before
class FoodTruckTests: XCTestCase {
  ...
}

// After
struct FoodTruckTests {
  ...
}

XCtest - setup and tear down.  Use init instead.  and deinit for teardown (but need a class for that)

// Before
class FoodTruckTests: XCTestCase {
  var batteryLevel: NSNumber!
  override func setUp() async throws {
    batteryLevel = 100
  }
  ...
}

// After
struct FoodTruckTests {
  var batteryLevel: NSNumber
  init() async throws {
    batteryLevel = 100
  }
  ...
}

XCTest is func testBlah() , while "the testing library" is @Test func blahblah(), so not name-driven any more.

XCTest runs sync test methods on the main actor by default.  The Testing Library™ runs them on an arbitrary task.  Decorate with @MainActor if you need those semantics,

or run the thread-sensitive code inside a call to MainActor.run(resultType:body:)

instead of XCTAssertWhatever, use the #expect and #require macros.  They're
like XCTAssert except require throws an error if the condition isn't met

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() throws {
    let engine = FoodTruck.shared.engine
    XCTAssertNotNil(engine.parts.first)
    XCTAssertGreaterThan(engine.batteryLevel, 0)
    try engine.start()
    XCTAssertTrue(engine.isRunning)
  }
  ....
}

// After
struct FoodTruckTests {
  @Test func engineWorks() throws {
    let engine = FoodTruck.shared.engine
    try #require(engine.parts.first != nil)
    #expect(engine.batteryLevel &gt; 0)
    try engine.start()
    #expect(engine.isRunning)
  }
  ...
}

XCTUnwrap to test if an optional is nil and throw if it does.
For The Testing Libary, use require with optional expressions to unwrap them

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() throws {
    let engine = FoodTruck.shared.engine
    let part = try XCTUnwrap(engine.parts.first)
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func engineWorks() throws {
    let engine = FoodTruck.shared.engine
    let part = try #require(engine.parts.first)
    ...
  }
  ...
}

XCTFail to fail immediately and uncondionally - useful when syntax prevents the use of XCTAssert

To do this, use record.

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() {
    let engine = FoodTruck.shared.engine
    guard case .electric = engine else {
      XCTFail("Engine is not electric")
      return
    }
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func engineWorks() {
    let engine = FoodTruck.shared.engine
    guard case .electric = engine else {
      Issue.record("Engine is not electric")
      return
    }
    ...
  }
  ...
}

And comparison table

XCTest
Swift Testing
XCTAssert(x), XCTAssertTrue(x)
#expect(x)
XCTAssertFalse(x)
#expect(!x)
XCTAssertNil(x)
#expect(x == nil)
XCTAssertNotNil(x)
#expect(x != nil)
XCTAssertEqual(x, y)
#expect(x == y)
XCTAssertNotEqual(x, y)
#expect(x != y)
XCTAssertIdentical(x, y)
#expect(x === y)
XCTAssertNotIdentical(x, y)
#expect(x !== y)
XCTAssertGreaterThan(x, y)
#expect(x &gt; y)
XCTAssertGreaterThanOrEqual(x, y)
#expect(x &gt;= y)
XCTAssertLessThanOrEqual(x, y)
#expect(x &lt;= y)
XCTAssertLessThan(x, y)
#expect(x &lt; y)
XCTAssertThrowsError(try f())
#expect(throws: (any Error).self) { try f() }
XCTAssertThrowsError(try f()) { error in … }
#expect { try f() } throws: { error in return … }
XCTAssertNoThrow(try f())
#expect(throws: Never.self) { try f() }
try XCTUnwrap(x)
try #require(x)
XCTFail("…")
Issue.record("…")

XCTestCas has continueAfterFailure, set to false to cause the test to stop runing after a failure occurs. (by throwing an objc exception) which tears through a swift stack frame causing damage (especialky an async function)

use require to throw a swift error that throws on failure. other tests will continue to run

// Before
class FoodTruckTests: XCTestCase {
  func testTruck() async {
    continueAfterFailure = false
    XCTAssertTrue(FoodTruck.shared.isLicensed)
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func truck() throws {
    try #require(FoodTruck.shared.isLicensed)
    ...
  }
  ...
}

Validate async behaviors

XCTEstExpectation / fulfilling expectaion, wait for it to be fulfilled

Prefer to use Swift concurrency  to validate async conditions.

if necessary to determine the result of an async swift function, can be awaited
with await. With a completion handler, can use a swift continuation to convert the call into an async-compatible one.

Some that can't be converted to use Swift concurrency, there's _confirmations_,
created andu sed in teh scope of the function (https://developer.apple.com/documentation/testing/confirmation)

Confirmations don't block or suspend the caller while waiting for a condition to be fulfilled.  The requirement is expected to be _confirmed_ (equivalent of fulfilling an expectation) before conformation returns

// Before
class FoodTruckTests: XCTestCase {
  func testTruckEvents() async {
    let soldFood = expectation(description: "…")
    FoodTruck.shared.eventHandler = { event in
      if case .soldFood = event {
        soldFood.fulfill()
      }
    }
    await Customer().buy(.soup)
    await fulfillment(of: [soldFood])
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func truckEvents() async {
    await confirmation("…") { soldFood in
      FoodTruck.shared.eventHandler = { event in
        if case .soldFood = event {
          soldFood()
        }
      }
      await Customer().buy(.soup)
    }
    ...
  }
  ...
}

XCTSkip error type can be thrown to bypass the remaineder of a test function.  Also XCTSkipIf and XCTSkipUnless

Can use ConditionTrait trait type

// Before
class FoodTruckTests: XCTestCase {
  func testArepasAreTasty() throws {
    try XCTSkipIf(CashRegister.isEmpty)
    try XCTSkipUnless(FoodTruck.sells(.arepas))
    ...
  }
  ...
}
// After
@Suite(.disabled(if: CashRegister.isEmpty))
struct FoodTruckTests {
  @Test(.enabled(if: FoodTruck.sells(.arepas)))
  func arepasAreTasty() {
    ...
  }
  ...
}

Annotating known issues

say a test has something that prevents it from passing.  With XCT, can do XCTExpectFailure

The Testingt Library has equivalents: withKnownIssue(_:isIntermittent:[isolation]:sourceLocation:)

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    XCTExpectFailure("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

XCTExpectFailure doesn't have a direct equivalent.  To mark a test as having a known issue, wrap its boyd with withKnownIssue

XCTExpectFialure can be marked non0strict.  with testing lib, specify that the known issue is intermittent instead

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    XCTExpectFailure(
      "Grill may need fuel",
      options: .nonStrict()
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue(
      "Grill may need fuel", 
      isIntermittent: true
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

Also withKnownIssues that take additional arguments with behavior
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:when:matching:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:when:matching:)

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    let options = XCTExpectedFailure.Options()
    options.isEnabled = FoodTruck.shared.hasGrill
    options.issueMatcher = { issue in
      issue.type == thrownError
    }
    XCTExpectFailure(
      "Grill is out of fuel",
      options: options
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    } when: {
      FoodTruck.shared.hasGrill
    } matching: { issue in
      issue.error != nil 
    }
    ...
  }
  ...
}

https://developer.apple.com/documentation/testing/known-issues

Highlight known issues when running tests.

use withKnownIssue() (and variants) to mark issues as known.  Informs the testing library at runtime not to mark the tests as failing when issues occur

Describe failure or warning via an Issue


(Grate) Expectataions and Confirmations, also by Edmund Welles

https://developer.apple.com/documentation/testing/expectations

check for expected values, outcomes, and async events in tests

Use expect(_:_:_:_:_:_:_:_:sourceLocation:) and require(_:_:sourceLocaton) macros (wheee) to validate expected outcomes.

To validate an error is (not) thrown, it provides overloads of the macros.

C.f. TESTING FOR ERRORS  https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code

Use a Confirmation (https://developer.apple.com/documentation/testing/confirmation) to confthe occurence of an async event.  
C.f. Testing AsyncCode (https://developer.apple.com/documentation/testing/testing-asynchronous-code)

Validating code's result - use expect.

The macro captures the expression passed in, and provides detailed info when the code doesn't statisfy the expecation

@Test func calculatingOrderTotal() {
  let calculator = OrderCalculator()
  #expect(calculator.total(of: [3, 3]) == 7)
  // Prints "Expectation failed: (calculator.total(of: [3, 3]) → 6) == 7"
}
Tests keep running after the expect fails.

To stop the test, use require

@Test func returningCustomerRemembersUsualOrder() throws {
  let customer = try #require(Customer(id: 123))
  // The test runner doesn't reach this line if the customer is nil.
  #expect(customer.usualOrder.countOfItems == 2)
}

require throws an instance of ExpectationFailedError when it fails

lots o' flavors.
EXPERIMENT TO DO:
	- try to do each of the expects and requires on https://developer.apple.com/documentation/testing/expectations
	- same with https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code


Testing for errors 
https://developer.apple.com/documentation/testing/testing-for-errors-in-swift-code

ensure your code handles errors in the way you expect.

Write test that valid the conditions in which the code throws errors and conditions in which it returns without throwing an error.

use overloads of expect/require to check for errors

Validate your code throws an expected erorr

Make a test function that throws and try the code under test. If the code throws an error, then your test fails.

To check that the code under test throws a specific error, or continue a longer test function after it throws, pass the error as the first argument of expect(throws:...) and pass a closure that calls the code under test

@Test func cannotAddToppingToPizzaBeforeStartOfList() {
  var order = PizzaToppings(bases: [.calzone, .deepCrust])
  #expect(throws: PizzaToppings.Error.outOfRange) {
    try order.add(topping: .mozarella, toPizzasIn: -1..&lt;0)
  }
}

If the closure completes without throwing an error,  it records an issue
Other overloads of expect let you test the code throws an error of a given type, or matches an arbitrary Boolean test.

Similar overloads of require stop running the test.

Validate it doesn't throw an error

a test function that throws an error means that it fails , usually sufficient for testing that code doesn't throw.

if need to record a thrown error as an issue without stopping the test, compare the error to Never

@Test func canAddToppingToPizzaInPositionZero() throws {
  var order = PizzaToppings(bases: [.thinCrust, .thinCrust])
  #expect(throws: Never.self) {
    try order.add(topping: .caper, toPizzasIn: 0..&lt;1)
  }
  let toppings = try order.toppings(forPizzaAt: 0)
  #expect(toppings == [.caper])
}

Testing Async Code

https://developer.apple.com/documentation/testing/testing-asynchronous-code

Validate your code causes expected events to happen

The Testing Library integrates with Swift Concurrency.  So can test async code using standard swift features.   Mark test as async, then in the body await any async interactions

@Test func priceLookupYieldsExpectedValue() async {
  let mozarellaPrice = await unitPrice(for: .mozarella)
  #expect(mozarellaPrice == 3)
}

In more complex situations can use Confirmation (https://developer.apple.com/documentation/testing/confirmationhttps://developer.apple.com/documentation/testing/confirmation)  to discover whether an expected event happens

Call confirmation(_:expectedCount:isolation:sourceLocation:_:) to create a Confirmation to for the expected event.  In the trailing closure parameter, call the code under test.
The Test Library passes a Confirmation as the parameter to the closure.  Call as afunction in the event handler for the code under test when the event testing for occurs.

@Test("OrderCalculator successfully calculates subtotal for no pizzas")
func subtotalForNoPizzas() async {
  let calculator = OrderCalculator()
  await confirmation() { confirmation in
    calculator.successHandler = { _ in confirmation() }
    _ = await calculator.subtotal(for: PizzaToppings(bases: []))
  }
}

(note not #confirmation - the mix of #blah and non-# blah is kind of confusing)

Set the expectedCount parameter to the number of times you expect the confirmation to be called.  Test passes if the number of occurences during the tst matches the expected count, before falling off the bottom of the crosure.

Confirming an event does _not_ happen - create a confirmation with an expected count of zero

@Test func orderCalculatorEncountersNoErrors() async {
  let calculator = OrderCalculator()
  await confirmation(expectedCount: 0) { confirmation in
    calculator.errorHandler = { _ in confirmation() }
    calculator.subtotal(for: PizzaToppings(bases: []))
  }
}


Parameterized Tests

Some tests need to be run over many different inputs. - might need to validate all cases in an enum.  TTL lets us specify one or more collections to iterate over during testing, with the elements being forward to a test function.

An invocation of the test function with a particular set of argument values is a _test case_

A group of test functions is a _basket case_

By default they run in parallel with each other. Saw earlier how to run them serially

over an array of values 

enum Food {
  case burger, iceCream, burrito, noodleBowl, kebab
}

@Test("All foods available", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])
func foodAvailable(_ food: Food) async throws {
  let foodTruck = FoodTruck(selling: food)
  #expect(await foodTruck.cook(food))
}

when passing a collection to @Test, the library passes each element of the collection, one at a time,. to the test function a its first (and only) argument.  If it fails for one or more inputs, the diagnostics clearly indicate which inputs to examine

over the cases of an enumeration - pass the EnumType.allCases (and of course need CaseIterable)

Going over a range of integers, can pass it a closed range.

@Test("Can make large orders", arguments: 1 ... 100)

heh.  "Note, very large ranges like 0 ..&lt; .max may take an excessive amount of time to test or may never complete"  - "please don't spray windex into eyes"

Any collection that's Sendable - Array / Set / OptionSet / Dictionary / Range

More than one collection (cartesian product). so say 5 fuds, this will be run FIVE HUNDRED times. 

@Test("Can make large orders", arguments: Food.allCases, 1 ... 100)
func makeLargeOrder(of food: Food, count: Int) async throws {
  let foodTruck = FoodTruck(selling: food)
  #expect(await foodTruck.cook(food, quantity: count))
}

To avoid the combinatorial asplosion, use zip

oh, and a maximum of two collections when not using zip

@Test("Can make large orders", arguments: zip(Food.allCases, 1 ... 100))

The zip sequence will be "destructured" into two arguments automagically. so like (.burger, 1), (.miceCream, 2), etc

Running selected test cases. - allows you to run specific test cases it contains - like if there's :alot: of cases, but only some are failing.

It must be deterministically match the test case's arguments.  When someone attepmts to run selectected test cases (how?) of a parameterized test function, TTL evaluates each argument of the test's cases for conformance to one of several known protocols.  if all arguments CONFORM, the test can be run selectively.
 	- CustomTestArgumentEncodable (https://developer.apple.com/documentation/testing/customtestargumentencodable) - for types that don't conform to Encodable or Decodable
	- Raw Representable where RawValue conforms to Encodable
	- Encodable
	- Identifiable where ID conforms to Encodable
(sounds like the selective test running depends on the parameter being Encodable.


Traits
https://developer.apple.com/documentation/testing/traits 
Add traits to tests to annotate them or customize their behavior

Pass built-in traits to test functions or suite types to comment, categorize, and modify runtime behaviors.  (so kind of the SwiftUI approach of "hey here's a bunch of different stuff stuff that all hangs off the same basic model)

Can use the Trait, TestTrait, and SuiteTrait protocols to create own types that customize the behavior of test functions

topics:
	- enabling and disabling tests
		- https://developer.apple.com/documentation/testing/enablinganddisabling
	- limiting running time
		- https://developer.apple.com/documentation/testing/limitingexecutiontime
	- adding tags to tests
		- https://developer.apple.com/documentation/testing/addingtags
	- adding comments
		- https://developer.apple.com/documentation/testing/addingcomments
	- associating bugs with tests
		- https://developer.apple.com/documentation/testing/associatingbugs
	- interpetting bug identifiers
		- https://developer.apple.com/documentation/testing/bugidentifiers

And more types:
	- Bug
	- Comment
	- ConditionTrait
	- ParallelizationTrait
	- Tag
	- List
	- TimeLimitTrait

(the rabbit hole just keeps going deeper and deeper)


Enalbing and disabling tests
https://developer.apple.com/documentation/testing/enablinganddisabling

sometimes a test is only applicable in specific circumstances - might want it to run on devices with particular hardware, or locale-dependent operations.  Can add traits to the tests that cause runners to automatically skip them if conditions are not met.

Note: Condition may be evaluated multiple times during testing. (not sure why they decided to call that out)

To disable unconditionally, use disabled function

@Test("Food truck sells burritos", .disabled())
func sellsBurritos() async throws { ... }

test will now always be skipped.

Can also give an optional comment.

enable or disable test conditionally - .enabled(if:)

@Test("Ice cream is cold", .enabled(if: Season.current == .summer))
func isCold() async throws { ... }

can have multiple conditions (so the @Test is very variadic). They all have to pass (or be no-ops)  Otherwise the runner notes the first condition to fail as the reason the test is skipped.

@Test(
  "Ice cream is cold",
  .enabled(if: Season.current == .summer),
  .disabled("We ran out of sprinkles")
)
func isCold() async throws { ... }

If it's due to a bug, can use the bug trait
@Test(
  "Ice cream is cold",
  .enabled(if: Season.current == .summer),
  .disabled("We ran out of sprinkles"),
  .bug(id: "12345")
)
func isCold() async throws { ... }

Can call functions in the test conditions to factor out complex logic

func allIngredientsAvailable(for food: Food) -&gt; Bool { ... }

@Test(
  "Can make sundaes",
  .enabled(if: Season.current == .summer),
  .enabled(if: allIngredientsAvailable(for: .sundae))
)
func makeSundae() async throws { ... }

Limiting Runtime
 https://developer.apple.com/documentation/testing/limitingexecutiontime

use timeLimit trait.  Multiple limits use the shortest one. defaults to one minute (and is configurable)

@Test(.timeLimit(.minutes(60))
func serve100CustomersInOneHour() async {
  for _ in 0 ..&lt; 100 {
    let customer = await Customer.next()
    await customer.order()
    ...
  }
}
(a 60 minute test? wtf...)

if the time limit runs out, the task that's running is cancelled, and test fails with a timeLimitExceeded issue

Can apply to test suites - recursively applied to all test functions and child test suites (sounds like then the time isn't for the entire suite, just bubbled down to the test functions.

Time limits on parameterized tests are applied to each invocation seperately. That way if one blorfs, then it won't incorrectly mark others as being blorfed

Adding tags to tests

use tags to provide semantic information for organization, filtering, and customizing appearances. 

a complex package may contain hundreds or thousands of tets and suites. Some may share a common facet, like being critical or flaky.  can use tags to add to the group and categorize tests.

Tags != test suites - suites impose structure on test functions on a source level.  Tags provide semantic information for a test that can be shared with any number of other tests across test suites, source files, or even test targets (how is that expressed?)

To add a tag, use the tags trait. - takes a sequence of tags as its argument, and those are applied to the test at runtime.

if any tags are applied to a test suite, then all tests inherit those tags.

TTL doesn't assign any semantic meaning to any tags, nor does it affect how the testing library runs tests.

Tags are instances of Tag and expressed as named constants.  Use the Tag macro:

extension Tag {
  @Tag static var legallyRequired: Self
}


@Test("Vendor's license is valid", .tags(.legallyRequired))
func licenseValid() { ... }

If two tags with the same name are declared in differnt files/modules/othercontext, TTL treats them as equivalent

If it's important to disambiguate, use reverse-DNS naming

extension Tag {
  enum com_example_foodtruck {}
}

extension Tag.com_example_foodtruck {
  @Tag static var extraSpecial: Tag
}

@Test(
  "Extra Special Sauce recipe is secret",
  .tags(.com_example_foodtruck.extraSpecial)
)
func secretSauce() { ... }

Tags must always be declared as a member of Tag in an extension (or in a nested type)

(and how are those tags used?)

Adding comments to tests
https://developer.apple.com/documentation/testing/addingcomments

- provide context or background info about code's urpose
- explain how complex code implemented [sic]
- includes details which may be helpful when diagnosing issues

Comments can be added to test declrations and TTL will automatically capture and show them when issues are recorded

// Assumes the standard lunch menu includes a taco
@Test func lunchMenu() {
  let foodTruck = FoodTruck(
    menu: .lunch,
    ingredients: [.tortillas, .cheese]
  )
  #expect(foodTruck.menu.contains { $0 is Taco })
}

Comments on tests are most useful when they
- add information not obvious from reading the code
- provide useful information about the operation or motivation of the test

if test is related to a bug or issue, consider using the Bug trait instead.

Associating bugs with tests
https://developer.apple.com/documentation/testing/associatingbugs

"bugs" can be referred to as "Issues" IRL,there is an Issue type in TTL, so the link refers to them all as Bugs

Three forms
	 - url representing the bug
	- unique identifier (string) (with or without url)
	- unique identifier (numeric) (with or without url)

@Test("Food truck engine works", .bug("https://www.example.com/issues/12345"))
func engineWorks() async {
  var foodTruck = FoodTruck()
  await foodTruck.engine.start()
  #expect(foodTruck.engine.isRunning)
}

Can also add a title.

@Test(
  "Food truck has napkins",
  .bug(id: "12345", "Forgot to buy more napkins")
)
func hasNapkins() async {
  ...
}

Interpreting bug identifiers
https://developer.apple.com/documentation/testing/bugidentifiers

how TTL interprets bug identifiers

Two ways to identify a bug:
	- url linking to more info
	- unique ID (string/id)
	- or both

It will infer bug tracking systems (github issues, webkit bugzilla, apple Feedbackdar black hole)

                                                                                                    
Now for the wwdc vids.

10195-Go further with Swift Testing

Not transcribing, just interesting notes

challenges
	- redability - easy to ead and understand
	- coverage
	- organizing
	- hidden dependencies make them fragile

Expressive cod
	- expectations - expect macro is more sophisticated
		- expectThrows - catch and examine error.  rather than writing the do / catch / etc
		- #expect(throws: (any Error).self) { try ... }
can also do more sophisticated via #expect throws macro

@Test func brewTea() {
	let teaLaves = ...
	#expect {
		try teaLeaves.brew(forMinutes: 3)
	} throws: { error in
		guard let error = error as? BewingError,
			case let .needsMoreTime(optimalBewTime) = error else {
			return false
		}
		return optionalBewTime == 4
	}
}

Don't disable tests, but use withKnownIssue - it'll continue complaining, but won't show up as failing. Then when it works, withKnownIssue will then fail so you know to remove it

Test descriptions (vs production code)

CONFORM to CustomTestStringConvertable, and provide a var testDescription: String {}

struct SoftServe: CustomTestStringConvertible {
	var testDescription: String {
		"\(flavor) in a \(container)"
	}
}

parameterized tests
	- since run in parallel, will run faster than a for loop
	test cases displayed in test navigator and test report

organizing tests
	- suites
	- document with names
	- suites can contain other suites
	- can add subsuites and show organizing the tests themselves
	- tags.  (like caffeniated vs chocolate foods, beacuse some can be both)
		- not a replacement for suites
		- suites impose structure at the source level
		- tags associate tests from different files/suites/targets that share something
		need @Tag before the static var caffeinented: Self (without assignemnt)
	- test navigator lets group by tags
	- filter matches function and tag names, tag filters
	- organize by tags with search field dingus
test plan editor can be driven by tag
	- list of test plans in the test navigator (~17:00)
		- can include and exclude tags. tags excluded are crossed out.
		- multiple tags is AND / OR
	- tags for anayzing results
		- pie chart.  lots of failures
		- tags appear in the outline.
		- there's a tags filter
		- insights screen - shows patterns in test failures
			- double click on the row
ignoring xcode cloud

parallel testing enabled by default.  Even across parallel devices
order is randomized  - surface hidden dependencies between tests

.serialized can be added to indicate will run serially. lose the advantages, so should fix it.
also to a parameteried function

waiting on async conditions
	- await works the same way
	- @24:48 - don't understand. Objc with a completion handler
		- "swift provides an async overload that does that automatically"

original: "runs after the test function returns" (the eat(cookies...) part)
@Test func bakeCookies () async throws {
	let cookies = await Cookie.bake(count: 10)
	eat (cookies, with: .milk) { result, error in
		#expect(result != nil)
	}
}

"automatic":

@Test func bakeCookies() async throws {
	let cookies = await Cookie.bake(count: 10)
	try await eat(cookies, with: .milk)
}

can do withChecked[Throwing]Continuation

event handlers that might call more than once.  Counting manually has data race issues
use confirmation


Want to compare floating point numbers?  We used to have XCTAssertEqual(_:_:accuracy:)
https://github.com/swiftlang/swift-testing/issues/165
Suggestion is to pull in swift-numerics, and use isApproximatelyEqual

Got spurious coverage?  See if the driver app is opening a document that happens to exercise things (had a document with some formatting, and wondering why my bold formatting stuff was getting covered)  Since you don't see it opening</Text>
        </Document>
        <Document ID="DA035F06-5C9F-47BF-8F93-ADECA9BF579D">
            <Title>Compiler Knows Things</Title>
            <Text>## Compiler knows things

If the compiler has no other recourse, it'll use existential containers:

func blah2(snorgles: [any Snorgle]) {
    print("  size: \(MemoryLayout&lt;any Snorgle&gt;.size)")
    print("  stride: \(MemoryLayout&lt;any Snorgle&gt;.stride)")
    print("  alignment: \(MemoryLayout&lt;any Snorgle&gt;.alignment)")
}
blah2(snorgles: [thing1, thing2])

which prints out the existential container size. But notice we can pass any kind of snorgle in there.

Because generics are known at compile time:

func blahArray&lt;T: Snorgle&gt;(snorgles: [T]) {
    print("  size: \(MemoryLayout&lt;T&gt;.size)")
    print("  stride: \(MemoryLayout&lt;T&gt;.stride)")
    print("  alignment: \(MemoryLayout&lt;T&gt;.alignment)")
}

can call with a uniform type
blahArray(snorgles: [thing1])
blahArray(snorgles: [thing2])

and the actual sizes are known (so no dispatching through an existential container)
</Text>
        </Document>
        <Document ID="1CDFACFC-26E5-4D80-9AD2-24B85C7FAFAE">
            <Title>Arrays (part 2)</Title>
            <Text>## Arrays part 2.  Moo

So, if you remember arrays part 1, you know that array storage is a linear chunk of stuff with the array contents laid end to end (using the _stride_ of the struct). This brings up a couple of interesting questions.

axiom #1: Arrays are value types . Structs are passed by copy. Copying a million element array, is kind of expensive. 

So arrays are implemented as a struct (yay value type), which wraps an object (yay reference type).  

The array points to its backing store.  If you pass the array around, small structs get peeled off, but all referencing the same dingus

(illustration)

if someone modifies the array, it'll make a copy(*) first, and then modify that. "Copy on Write". So the expensive operation is paid by the one who is doing the copying.


</Text>
        </Document>
        <Document ID="C50A3C19-EF63-4307-A97F-85C2EFBBC7AB">
            <Title>Syntax bits</Title>
        </Document>
        <Document ID="FB15E44A-6E03-4785-BC39-87C5FE716CF7">
            <Title>Structure Layout</Title>
            <Text># Structure Layout

C has pretty straightforward rules on how structures are represented in memory.  Structs defined from C will have the same size, layout, and alignment.


Does Swift do the same thing?  Pretty much

how to tell the size 

(layout.swift)

MemoryLayout 

MemoryLayout&lt;Thing1&gt;.size
MemoryLayout&lt;Thing1&gt;.stride
MemoryLayout&lt;Thing1&gt;.alignment

MemoryLayout&lt;Thing1&gt;.offset(of: \.aBool)


(diagram thing1 and thing2)

struct Thing1 {
    let aBool: Bool
    let anInt: Int
    let anotherBool: Bool
    let short: Int16
    let anotherInt: Int
}

struct Thing2 {
    let anInt: Int = 0
    let anotherInt: Int = 0
    let aBool: Bool = false
    let anotherBool: Bool = false
    let short: Int16 = 0
}

(bop out and run layout.swift)

Thing 1
  size: 32
  stride: 32
  alignment: 8

  aBool offset: 0
  anInt offset: 8
  anotherBool offset: 16
  short offset: 18
  anotherInt offset: 24
------------------------------
Thing 2
  size: 20
  stride: 24
  alignment: 8

  anInt offset: 0
  anotherInt offset: 8
  aBool offset: 16
  anotherBool offset: 17
  short offset: 18


just for funsies, change thing 2 into a class


Thing 2
  size: 8
  stride: 8
  alignment: 8

Trace/BPT trap

huh.  Where'd all the numbers go?

</Text>
        </Document>
        <Document ID="F40AE388-1C45-493D-AF10-31C1A82B1D5A">
            <Text>## Arrays

In many performance-oriented languages, arrays have a particular implemention that makes them very fast for what they do.

- large contiguous chunk of memory
- uniform size of entities

This allows easy "pointer plus scaled offset" for indexing.  If you know your array items are 30 bytes long, you can figure out the address in memory for the N'th item by doing baseAddress + N * 30.  makes random access really fast

And because arrays are in a contiguous chunka bytes, iterative scanning through them (for i in 0 .. size; do stuff with array[i]) take advantage of the processor's prefetching behavior.

SO, knowing that, things like   func blah(array: [any Greeble]) - my brain went into vapor-lock.  Greebles can be enums, or structs, or classes.  all different sizes. HOW CAN THAT WORK?!??!



</Text>
        </Document>
        <Document ID="9244C190-7AFE-4065-A947-59F2898F796E">
            <Title>Syntax bits</Title>
            <Text>@Test
	- macro
	- two documented arguments, displayName (nil default), and traits (zero or more, variadic)
	- .tags (as traits)
#require
@Suite
	- declares a test suite
Issues - https://developer.apple.com/documentation/testing/issue/record(_:sourcelocation:)
	-  type describing a failure or warning which occurred during a test
	- comments
	- error
	- kind (Issue.kind)
		- apiMisued (due to misuse of the testing liberry)
		- confiremationMiscounted(actual, expected)
		- errorCaught(error)
		- expectationFailed(Expectation)
		- knownIssueNotRecorded - known issue was expected but not recorded
		- system - the underlying system had a problem, not the test
		- timeLimitExceeded(seconds/attoseconds
		- unconditional (like record)
	- sourceLocation
	- record(...)
Confirmation - https://developer.apple.com/documentation/testing/confirmation
	- https://developer.apple.com/documentation/testing/issue
Expectation - https://developer.apple.com/documentation/testing/expectation 
	- also FailedError for failed expectations
	- type describing an expectation that has been evaluated
CustomTestArgumentEncodable - https://developer.apple.com/documentation/testing/customtestargumentencodable

expectations
	- #expect - https://developer.apple.com/documentation/testing/expect(_:_:sourcelocation:)
	- #require - https://developer.apple.com/documentation/testing/require(_:_:sourcelocation:)

	- when to use which?  Looking at the migration guide, it seems kind of arbitrary which one is used.  Expect keeps running, require stops
tests vs suites
	- test suite is a type that contains test functions

traits (https://developer.apple.com/documentation/testing/traits)
	- tags (https://developer.apple.com/documentation/testing/trait/tags(_:))
		- .metadata (might just be an example)
	- disabled (https://developer.apple.com/documentation/testing/trait/disabled(_:sourcelocation:))
	- serialized (https://developer.apple.com/documentation/testing/trait/serialized)
	- condition (https://developer.apple.com/documentation/testing/conditiontrait)
		- enabled / disabled
  - Trait, TestTrait, and SuiteTrait protocols

Confirmations - https://developer.apple.com/documentation/testing/confirmation
	-  await confirmation("…") { blah in

withKnownIssue - https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)
	- KnownIssueMatcher - https://developer.apple.com/documentation/testing/knownissuematcher

traits
.enabled(if:)
	- Bug
	- Comment
	- ConditionTrait
	- ParallelizationTrait
	- Tag
	- List
	- TimeLimitTrait

swift test
	- --no-parallel


Random interesting exampules

let customer = try #require(Customer(id: 123))

  #expect(throws: Never.self) { // if it throws, record an error, but don't kill the test
    try order.add(topping: .caper, toPizzasIn: 0..&lt;1)
  }

</Text>
        </Document>
        <Document ID="3235AABD-C6FC-41FE-BF87-81C6694566F1">
            <Title>Inline representation</Title>
            <Text>## Inline Representation

the inline representation is how a particular swift Thing is, well, represented in memory.  

Specifically, when doing things like storing it in variables, passing it around from function to function, or putting things into collections.

As we saw, the inline representation of a structure is the goodies in the structure.  I don't think it's officially documented (outside of random forum postings by Swift Core Team Members), but structs are generally laid out in memory like described.

when structs are passed around, I like to use the "peel off a copy metaphor". I have this structure. I'm going to pass it to this function or I'm going to assign it to this variable.  I'm going to peel off a copy and give you that copy.  This copy I'm peeling off is the inline representation. I'll take the inline representation of my structure, duplicate it, and pass that inline representation to the function, or where the variable's storage is.  

This is how the Value Semantics work. Because you have your own peeled-off copy, you can do whatever you want with it and my pristine original is unaffacted


Classes though, are reference types.  When passing a reference type around, all you have to do is say "uh, hey, you can find this thing over there", giving it the address in memory where that object lives.  a.k.a. a pointer to the chunk of memory that has the object's properties.

This means the inline representation for class instances is going to be the size of a pointer, which is going to be 8 bytes (iOS, Mac, etc), or 4 bytes (on Playdate and other embedded systems)
</Text>
        </Document>
    </Documents>
</SearchIndexes>