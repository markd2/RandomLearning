<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="5641A8C0-884F-4C39-9C47-EB7BFACB73F1">
            <Title>Swift Under the Hood</Title>
            <Text># Swift under the hood

Things like in-memory representation, existential containers, witness tables, etc.

Big caveat - don't use this information to make decisions, unless you know you should use this information to make decisions.

"you should have an intuition for what performance different language features give you"

I know for me, I get all sorts of "oh, so that's how $SOMETHING works" hits of dopamine with these things (as we'll see with arrays)
</Text>
        </Document>
        <Document ID="C1DD02B5-E104-40F2-B910-750B9D444DB6">
            <Title>csh time builtin output format</Title>
            <Text>%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww

%U
The time the process spent in user mode in cpu seconds.

%S
The time the process spent in kernel mode in cpu seconds.

%E
The elapsed (wall clock) time in seconds.

%P
The CPU percentage computed as (%U + %S) / %E.


%X
The average amount in (shared) text space used in Kbytes.
%D
The average amount in (unshared) data/stack space used in Kbytes.

%I
The number of input operations.
%O
The number of output operations.

%F
The number of major page faults (page needed to be brought from disk).
%W
Number of times the process was swapped.

</Text>
        </Document>
        <Document ID="DDA87D8C-29B8-462D-9839-BA2FEBC09AC4">
            <Title>Benchmarking</Title>
            <Text>## Benchmarking

I was going to do some really cheesy benchmarking but ran out of time.

But folks might not realize the disparity between Swift's performance in debug and release mode.

Make sure you're optimizing if you're doing any kind of real comparisons.  Unoptimized Swift is a porker.

for example

test-opt.swift

let n = 10000
var x = [Int](repeating: 1, count: n)

for i in 0 ..&lt; n {
    for j in 0 ..&lt; n {
        x[i] ^= x[j] &lt;&lt; (i+j) % 16
    }
}
print("blah: \(x[0])")

% swiftc    test-opt.swift -o tg
% swiftc -O test-opt.swift -o to


% time ./to
blah: 14
0.252u 0.002s 0:00.25 100.0%    0+0k 0+0io 4pf+0w

while tg is running, explain the output of time

% time ./tg
blah: 14
26.189u 0.018s 0:26.50 98.8%    0+0k 0+0io 13pf+0w


So like two orders of magnitude faster - 26 seconds for "only" 100,000,000 bits of work is not fast.  Sometimes this is really noticeable with the swift algorithms, like doing a permutation over a set.
</Text>
        </Document>
        <Document ID="EAAE4896-FE10-41C8-B75B-D849D5D4837F">
            <Title>Protocols</Title>
            <Text>## Protocols

One of swift's defining features is its ability to add layers of abstraction and polymorphism via protocols.  A protocol describes some subset of functionality (say "codable" or "human biometric provider") 

So revisit layout.swift

protocol Snorgle {
    var anInt: Int { get }
/*
    var aBool: Bool { get }
    var anotherInt: Int { get }
    var anotherBool: Bool { get }
    var short: Int16 { get }

    func x()
    func y()
    func z()
    func q()
*/
}

extension Thing1: Snorgle {
    func x() {}
    func y() {}
    func z() {}
    func q() {}
}

extension Thing2: Snorgle {
    func x() {}
    func y() {}
    func z() {}
    func q() {}
}
and run, and get

Snorgle
  size: 40
  stride: 40
  alignment: 8
  anInt offset: -1
  aBool offset: -1

if you throw more things in to it, the thing doesn't get any bigger.

The alignment of 8 implies that there's a data type that requires 8-byte alignment, so probably pointers involved.  size of 40 would mean five pointers.

"Any problem can be solved with an additional layer of indirection"



</Text>
        </Document>
        <Document ID="BA1108B6-D88C-4C58-9629-189F748F2CFE">
            <Title>More than a copy</Title>
            <Text>## More than a copy

So, class instances need to be retained when used, and released when done with.  If I pass an object to a function, it gets retained on the way in (reference count incremented), and released (reference count decremented) on the way out. 

if I assign an object to a local property, it gets retained when assigned, and then if a new value is assigned, the original is released.

When the reference count hits zero, the memory is freed.  Notice memory is freed, so that implies that the object has been allocated.  You can think of objects living in the heap.  Structures can live anywhere their inline representation can live.  So a structure can be passed on the C stack without involving expensive dynamic memory.

So, what if a struct contains references to objects? Those need to be retained and released

(struct-class.swift)


</Text>
        </Document>
        <Document ID="AE8BCB40-8CD3-44E9-A029-EFDBFB897DD4">
            <Title>Existential Containers</Title>
            <Text>## Existential Containers

one pointer for the witness table
three word-size for inline-storage, otherwise flow out to dynamic memory (based on scoping)
and not sure what the other word is for

</Text>
        </Document>
        <Document ID="C341F091-E04B-4D12-B18F-6685DA0A50E7">
            <Title>xcrud 15 vs 16</Title>
            <Text>IIRC built into xc16. for 15, you need some hoops

</Text>
        </Document>
        <Document ID="4D3CF17A-C9DB-4703-864D-115FCC3E8777">
            <Title>Bucket of Notes</Title>
            <Text>Swift Testing

New and improved testing frameworkke

                                                                                                    

https://developer.apple.com/xcode/swift-testing/

Clear Expressive API

* declare complex behaviors with a small amount of code
* #expect uses Swift expressions and operators
	- captures evaluated values so can quickly understand what went wrong
* Parameterized tests run the same test over a sequence of values
* integrate seamlessly with Swift Concurrency and run in parallel by default

@Test("Continents mentioned in videos", arguments: [
    "A Beach",
    "By the Lake",
    "Camping in the Woods"
])
func mentionedContinents(videoName: String) async throws {
    let videoLibrary = try await VideoLibrary()
    let video = try #require(await videoLibrary.video(named: videoName))
    #expect(video.mentionedContinents.count &lt;= 3)
}

Custom test behaviors

Can customize behavior of test/suites using traits.
Can describe the runtime conditions for a test
	- which device a test should ruin on
	- limt test to a certain OS system versions
	- help in CI by specifying execution time limits

@Test(.enabled(if: AppFeatures.isCommentingEnabled))
func videoCommenting() async throws {
    let video = try #require(await videoLibrary.video(named: "A Beach"))
    #expect(video.comments.contains("So picturesque!"))
}

Easy and Flexible Organization

Provides many ways to keep your tests organized.
	- structure related tests using a hierarchy of groups and subgroups
	- apply tags to flexibly manage, edit, and run tests with common characteristics across your test suite
	- also give tests a descriptive name

@Test("Check video metadata",
      .tags(.metadata))
func videoMetadata() {
    let video = Video(fileName: "By the Lake.mov")
    let expectedMetadata = Metadata(duration: .seconds(90))
    #expect(video.metadata == expectedMetadata)
}

Tooling

work with tests and suites inside of xcrud
inline presentations of tst results
re-run specific arguments for parameterized tests for debugging

run from the command line using SPM (yay!)

Open Source / Cross Platform

works on all major platforms.
Tests can behave more consistently when moving between platforms.
open source

works with XCTest

can run side-by-side with newer SwiftTesting

                                                                                                    

https://developer.apple.com/documentation/testing/

intro blurb
Develop tests with more confidence and less code
integrates seamlessly with SPM testing workflow
customizable metadata
scalable test execution

- define test functions almost anywhere with a single attribute
- group related tests into hierarchies using Swift's type system
- integrate seamlessly with Swift Concurrency
- Parameterize test functions
- enable tests dynamically depending on runtime conditions
	- hopefully there's a phase of moon attribute
- paralleize tests in-process
- categorize tests using tags
- associate bugs directly with the tests that verify their fixes or repro their problems
	- interesting

Defining Test Functions

https://developer.apple.com/documentation/testing/definingtests

"definite a test function to validate that code is working correctly:

Article assumes the package or project has already been configured with a test target (c.f. https://developer.apple.com/documentation/Xcode/test-coverage)

import Testing

Note:
	- Only import the testing liberry into a test target
	- importing into an application, libary, or binary target isn't supported / recommended
	- test functions aren't stripped from binaries when building for release, so all sorts of stuff could be visible

Declaring a test function

@Test func foodTruckExists() {
    // test logic goes here
}

can be at file-scope or inside a type

A type containing test functions is automatically a test suite.  c.f. https://developer.apple.com/documentation/testing/organizingtests

The above function doesn't do much.  Add expectations to the test function. c.f. Edmund Welles https://developer.apple.com/documentation/testing/expectations

Can customize the test name's (so when it's surfaced in an IDE or command line" - can add a string literal to the @Test attribute

@Test("Food truck exists") func foodTruckExists() { ... }

To further customize appearance and behavior of a test function, use traits like tags(_:)

concurrent or throwing tests

can decorate the test with async / throws / @MainActor

limiting availability

For running on newer versions of OS or language, use @available.  e.g.
	@available(swift, introduced: 8.0, message: "Requires Swift 8.0 features to run")

and can also use @available for things like an OS gate (@available(macOS 11.0, *))

There's also migrating a test from XCTest, via https://developer.apple.com/documentation/testing/migratingfromxctest

Test Suite Types

https://developer.apple.com/documentation/testing/organizingtests

When working with a large chunk of functions, helpful to organize them into test suites.

Two ways
- placing it into a Swift type
- placing it in a swift type and annotating that type with the @Suite attributt

@Suite isn't required to recognize a type contains test functions.  Does allow customization of the test's appearance in tooling.  Traits like tags/disabled are inherited by the test in the suite

Can have nested test suites

tests within a suite run in parallel. c.f. https://developer.apple.com/documentation/testing/parallelization

customizing name

@Suite("Food truck tests") struct FoodTruckTests {
  @Test func foodTruckExists() { ... }
}

test functions in a test suite type

instance method test functions, the library calls that by initialziing an instance of the type, then calling the test function

So these two are equivalent

@Suite struct FoodTruckTests {
  @Test func foodTruckExists() { ... }
}

@Suite struct FoodTruckTests {
  func foodTruckExists() { ... }


  @Test static func staticFoodTruckExists() {
    let instance = FoodTruckTests()
    instance.foodTruckExists()
  }
}

limitations / constraints on suite types

an initializer may be required
	- may be implicit or explicit
	- sync or async
	- throwing or non-thorwing
	- private/fileprivate / internal / package / public

Test suite types must always be available - not annotated with @available


https://developer.apple.com/documentation/testing/parallelization
Running tests serially or in parallel

testing library uses task groups, and tests all run in the same process.

number of tests that run concurrently s controlled by the runtime

parallelization can be disabled on a per-function or a per-suite basis using serialized

@Test(.serialized, arguments: Food.allCases) func prepare(food: Food) {
  // This function will be invoked serially, once per food, because it has the
  // .serialized trait.
}


@Suite(.serialized) struct FoodTruckTests {
  @Test(arguments: Condiment.allCases) func refill(condiment: Condiment) {
    // This function will be invoked serially, once per condiment, because the
    // containing suite has the .serialized trait.
  }


  @Test func startEngine() async throws {
    // This function will not run while refill(condiment:) is running. One test
    // must end before the other will start.
  }
}

when added to a parameterized test function, serialized causes that test to run its cases serially instead of paralle.

When applied to a non-param test function, has no effect

When applied to a test suite, causes it to run the contained test functions and sub-suites serially

Recursively applied through embedded suites

doesn't affect execution of a test relative to its peers or unrelated tests.

has no effect if parallelization is globally disabled (e.g. --no-parallel to swift test)

Migrating from XCTest

https://developer.apple.com/documentation/testing/migratingfromxctest

Can coexist in the same file

XCTest groups related sets of test methods in test calsses inheriting from XCTestCase.
Can be free or global, or static or class members of a type.

To convert XCTestCase to a suite, remove the XCTestCase CONFORMance.

Swift structure or actor be used to better enforce concurrency saftey

// Before
class FoodTruckTests: XCTestCase {
  ...
}

// After
struct FoodTruckTests {
  ...
}

XCtest - setup and tear down.  Use init instead.  and deinit for teardown (but need a class for that)

// Before
class FoodTruckTests: XCTestCase {
  var batteryLevel: NSNumber!
  override func setUp() async throws {
    batteryLevel = 100
  }
  ...
}

// After
struct FoodTruckTests {
  var batteryLevel: NSNumber
  init() async throws {
    batteryLevel = 100
  }
  ...
}

XCTest is func testBlah() , while "the testing library" is @Test func blahblah(), so not name-driven any more.

XCTest runs sync test methods on the main actor by default.  The Testing Library™ runs them on an arbitrary task.  Decorate with @MainActor if you need those semantics,

or run the thread-sensitive code inside a call to MainActor.run(resultType:body:)

instead of XCTAssertWhatever, use the #expect and #require macros.  They're
like XCTAssert except require throws an error if the condition isn't met

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() throws {
    let engine = FoodTruck.shared.engine
    XCTAssertNotNil(engine.parts.first)
    XCTAssertGreaterThan(engine.batteryLevel, 0)
    try engine.start()
    XCTAssertTrue(engine.isRunning)
  }
  ....
}

// After
struct FoodTruckTests {
  @Test func engineWorks() throws {
    let engine = FoodTruck.shared.engine
    try #require(engine.parts.first != nil)
    #expect(engine.batteryLevel &gt; 0)
    try engine.start()
    #expect(engine.isRunning)
  }
  ...
}

XCTUnwrap to test if an optional is nil and throw if it does.
For The Testing Libary, use require with optional expressions to unwrap them

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() throws {
    let engine = FoodTruck.shared.engine
    let part = try XCTUnwrap(engine.parts.first)
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func engineWorks() throws {
    let engine = FoodTruck.shared.engine
    let part = try #require(engine.parts.first)
    ...
  }
  ...
}

XCTFail to fail immediately and uncondionally - useful when syntax prevents the use of XCTAssert

To do this, use record.

// Before
class FoodTruckTests: XCTestCase {
  func testEngineWorks() {
    let engine = FoodTruck.shared.engine
    guard case .electric = engine else {
      XCTFail("Engine is not electric")
      return
    }
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func engineWorks() {
    let engine = FoodTruck.shared.engine
    guard case .electric = engine else {
      Issue.record("Engine is not electric")
      return
    }
    ...
  }
  ...
}

And comparison table

XCTest
Swift Testing
XCTAssert(x), XCTAssertTrue(x)
#expect(x)
XCTAssertFalse(x)
#expect(!x)
XCTAssertNil(x)
#expect(x == nil)
XCTAssertNotNil(x)
#expect(x != nil)
XCTAssertEqual(x, y)
#expect(x == y)
XCTAssertNotEqual(x, y)
#expect(x != y)
XCTAssertIdentical(x, y)
#expect(x === y)
XCTAssertNotIdentical(x, y)
#expect(x !== y)
XCTAssertGreaterThan(x, y)
#expect(x &gt; y)
XCTAssertGreaterThanOrEqual(x, y)
#expect(x &gt;= y)
XCTAssertLessThanOrEqual(x, y)
#expect(x &lt;= y)
XCTAssertLessThan(x, y)
#expect(x &lt; y)
XCTAssertThrowsError(try f())
#expect(throws: (any Error).self) { try f() }
XCTAssertThrowsError(try f()) { error in … }
#expect { try f() } throws: { error in return … }
XCTAssertNoThrow(try f())
#expect(throws: Never.self) { try f() }
try XCTUnwrap(x)
try #require(x)
XCTFail("…")
Issue.record("…")

XCTestCas has continueAfterFailure, set to false to cause the test to stop runing after a failure occurs. (by throwing an objc exception) which tears through a swift stack frame causing damage (especialky an async function)

use require to throw a swift error that throws on failure. other tests will continue to run

// Before
class FoodTruckTests: XCTestCase {
  func testTruck() async {
    continueAfterFailure = false
    XCTAssertTrue(FoodTruck.shared.isLicensed)
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func truck() throws {
    try #require(FoodTruck.shared.isLicensed)
    ...
  }
  ...
}

Validate async behaviors

XCTEstExpectation / fulfilling expectaion, wait for it to be fulfilled

Prefer to use Swift concurrency  to validate async conditions.

if necessary to determine the result of an async swift function, can be awaited
with await. With a completion handler, can use a swift continuation to convert the call into an async-compatible one.

Some that can't be converted to use Swift concurrency, there's _confirmations_,
created andu sed in teh scope of the function (https://developer.apple.com/documentation/testing/confirmation)

Confirmations don't block or suspend the caller while waiting for a condition to be fulfilled.  The requirement is expected to be _confirmed_ (equivalent of fulfilling an expectation) before conformation returns

// Before
class FoodTruckTests: XCTestCase {
  func testTruckEvents() async {
    let soldFood = expectation(description: "…")
    FoodTruck.shared.eventHandler = { event in
      if case .soldFood = event {
        soldFood.fulfill()
      }
    }
    await Customer().buy(.soup)
    await fulfillment(of: [soldFood])
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func truckEvents() async {
    await confirmation("…") { soldFood in
      FoodTruck.shared.eventHandler = { event in
        if case .soldFood = event {
          soldFood()
        }
      }
      await Customer().buy(.soup)
    }
    ...
  }
  ...
}

XCTSkip error type can be thrown to bypass the remaineder of a test function.  Also XCTSkipIf and XCTSkipUnless

Can use ConditionTrait trait type

// Before
class FoodTruckTests: XCTestCase {
  func testArepasAreTasty() throws {
    try XCTSkipIf(CashRegister.isEmpty)
    try XCTSkipUnless(FoodTruck.sells(.arepas))
    ...
  }
  ...
}
// After
@Suite(.disabled(if: CashRegister.isEmpty))
struct FoodTruckTests {
  @Test(.enabled(if: FoodTruck.sells(.arepas)))
  func arepasAreTasty() {
    ...
  }
  ...
}

Annotating known issues

say a test has something that prevents it from passing.  With XCT, can do XCTExpectFailure

The Testingt Library has equivalents: withKnownIssue(_:isIntermittent:[isolation]:sourceLocation:)

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    XCTExpectFailure("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}
// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

XCTExpectFailure doesn't have a direct equivalent.  To mark a test as having a known issue, wrap its boyd with withKnownIssue

XCTExpectFialure can be marked non0strict.  with testing lib, specify that the known issue is intermittent instead

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    XCTExpectFailure(
      "Grill may need fuel",
      options: .nonStrict()
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue(
      "Grill may need fuel", 
      isIntermittent: true
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

Also withKnownIssues that take additional arguments with behavior
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:sourcelocation:_:when:matching:)
* https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:when:matching:)

// Before
class FoodTruckTests: XCTestCase {
  func testGrillWorks() async {
    let options = XCTExpectedFailure.Options()
    options.isEnabled = FoodTruck.shared.hasGrill
    options.issueMatcher = { issue in
      issue.type == thrownError
    }
    XCTExpectFailure(
      "Grill is out of fuel",
      options: options
    ) {
      try FoodTruck.shared.grill.start()
    }
    ...
  }
  ...
}

// After
struct FoodTruckTests {
  @Test func grillWorks() async {
    withKnownIssue("Grill is out of fuel") {
      try FoodTruck.shared.grill.start()
    } when: {
      FoodTruck.shared.hasGrill
    } matching: { issue in
      issue.error != nil 
    }
    ...
  }
  ...
}

https://developer.apple.com/documentation/testing/known-issues

Highlight known issues when running tests.

use withKnownIssue() (and variants) to mark issues as known.  Informs the testing library at runtime not to mark the tests as failing when issues occur

Describe failure or warning via an Issue


https://developer.apple.com/documentation/testing/expectations

check for expected values, outcomes, and async events in tests
</Text>
        </Document>
        <Document ID="DA035F06-5C9F-47BF-8F93-ADECA9BF579D">
            <Title>Compiler Knows Things</Title>
            <Text>## Compiler knows things

If the compiler has no other recourse, it'll use existential containers:

func blah2(snorgles: [any Snorgle]) {
    print("  size: \(MemoryLayout&lt;any Snorgle&gt;.size)")
    print("  stride: \(MemoryLayout&lt;any Snorgle&gt;.stride)")
    print("  alignment: \(MemoryLayout&lt;any Snorgle&gt;.alignment)")
}
blah2(snorgles: [thing1, thing2])

which prints out the existential container size. But notice we can pass any kind of snorgle in there.

Because generics are known at compile time:

func blahArray&lt;T: Snorgle&gt;(snorgles: [T]) {
    print("  size: \(MemoryLayout&lt;T&gt;.size)")
    print("  stride: \(MemoryLayout&lt;T&gt;.stride)")
    print("  alignment: \(MemoryLayout&lt;T&gt;.alignment)")
}

can call with a uniform type
blahArray(snorgles: [thing1])
blahArray(snorgles: [thing2])

and the actual sizes are known (so no dispatching through an existential container)
</Text>
        </Document>
        <Document ID="1CDFACFC-26E5-4D80-9AD2-24B85C7FAFAE">
            <Title>Arrays (part 2)</Title>
            <Text>## Arrays part 2.  Moo

So, if you remember arrays part 1, you know that array storage is a linear chunk of stuff with the array contents laid end to end (using the _stride_ of the struct). This brings up a couple of interesting questions.

axiom #1: Arrays are value types . Structs are passed by copy. Copying a million element array, is kind of expensive. 

So arrays are implemented as a struct (yay value type), which wraps an object (yay reference type).  

The array points to its backing store.  If you pass the array around, small structs get peeled off, but all referencing the same dingus

(illustration)

if someone modifies the array, it'll make a copy(*) first, and then modify that. "Copy on Write". So the expensive operation is paid by the one who is doing the copying.


</Text>
        </Document>
        <Document ID="C50A3C19-EF63-4307-A97F-85C2EFBBC7AB">
            <Title>Syntax bits</Title>
        </Document>
        <Document ID="FB15E44A-6E03-4785-BC39-87C5FE716CF7">
            <Title>Structure Layout</Title>
            <Text># Structure Layout

C has pretty straightforward rules on how structures are represented in memory.  Structs defined from C will have the same size, layout, and alignment.


Does Swift do the same thing?  Pretty much

how to tell the size 

(layout.swift)

MemoryLayout 

MemoryLayout&lt;Thing1&gt;.size
MemoryLayout&lt;Thing1&gt;.stride
MemoryLayout&lt;Thing1&gt;.alignment

MemoryLayout&lt;Thing1&gt;.offset(of: \.aBool)


(diagram thing1 and thing2)

struct Thing1 {
    let aBool: Bool
    let anInt: Int
    let anotherBool: Bool
    let short: Int16
    let anotherInt: Int
}

struct Thing2 {
    let anInt: Int = 0
    let anotherInt: Int = 0
    let aBool: Bool = false
    let anotherBool: Bool = false
    let short: Int16 = 0
}

(bop out and run layout.swift)

Thing 1
  size: 32
  stride: 32
  alignment: 8

  aBool offset: 0
  anInt offset: 8
  anotherBool offset: 16
  short offset: 18
  anotherInt offset: 24
------------------------------
Thing 2
  size: 20
  stride: 24
  alignment: 8

  anInt offset: 0
  anotherInt offset: 8
  aBool offset: 16
  anotherBool offset: 17
  short offset: 18


just for funsies, change thing 2 into a class


Thing 2
  size: 8
  stride: 8
  alignment: 8

Trace/BPT trap

huh.  Where'd all the numbers go?

</Text>
        </Document>
        <Document ID="F40AE388-1C45-493D-AF10-31C1A82B1D5A">
            <Text>## Arrays

In many performance-oriented languages, arrays have a particular implemention that makes them very fast for what they do.

- large contiguous chunk of memory
- uniform size of entities

This allows easy "pointer plus scaled offset" for indexing.  If you know your array items are 30 bytes long, you can figure out the address in memory for the N'th item by doing baseAddress + N * 30.  makes random access really fast

And because arrays are in a contiguous chunka bytes, iterative scanning through them (for i in 0 .. size; do stuff with array[i]) take advantage of the processor's prefetching behavior.

SO, knowing that, things like   func blah(array: [any Greeble]) - my brain went into vapor-lock.  Greebles can be enums, or structs, or classes.  all different sizes. HOW CAN THAT WORK?!??!



</Text>
        </Document>
        <Document ID="9244C190-7AFE-4065-A947-59F2898F796E">
            <Title>Syntax bits</Title>
            <Text>@Test
	- macro
	- two documented arguments, displayName (nil default), and traits (zero or more, variadic)
	- .tags (as traits)
#require
@Suite
	- declares a test suite
Issues - https://developer.apple.com/documentation/testing/issue/record(_:sourcelocation:)
	- https://developer.apple.com/documentation/testing/issue

expectations
	- #expect - https://developer.apple.com/documentation/testing/expect(_:_:sourcelocation:)
	- #require - https://developer.apple.com/documentation/testing/require(_:_:sourcelocation:)
	- when to use which?  Looking at the migration guide, it seems kind of arbitrary which one is used

tests vs suites
	- test suite is a type that contains test functions

traits (https://developer.apple.com/documentation/testing/traits)
	- tags (https://developer.apple.com/documentation/testing/trait/tags(_:))
		- .metadata (might just be an example)
	- disabled (https://developer.apple.com/documentation/testing/trait/disabled(_:sourcelocation:))
	- serialized (https://developer.apple.com/documentation/testing/trait/serialized)
	- condition (https://developer.apple.com/documentation/testing/conditiontrait)
		- enabled / disabled

Confirmations - https://developer.apple.com/documentation/testing/confirmation
	-  await confirmation("…") { blah in

withKnownIssue - https://developer.apple.com/documentation/testing/withknownissue(_:isintermittent:isolation:sourcelocation:_:)
	- KnownIssueMatcher - https://developer.apple.com/documentation/testing/knownissuematcher

traits
.enabled(if:)

swift test
	- --no-parallel
</Text>
        </Document>
        <Document ID="3235AABD-C6FC-41FE-BF87-81C6694566F1">
            <Title>Inline representation</Title>
            <Text>## Inline Representation

the inline representation is how a particular swift Thing is, well, represented in memory.  

Specifically, when doing things like storing it in variables, passing it around from function to function, or putting things into collections.

As we saw, the inline representation of a structure is the goodies in the structure.  I don't think it's officially documented (outside of random forum postings by Swift Core Team Members), but structs are generally laid out in memory like described.

when structs are passed around, I like to use the "peel off a copy metaphor". I have this structure. I'm going to pass it to this function or I'm going to assign it to this variable.  I'm going to peel off a copy and give you that copy.  This copy I'm peeling off is the inline representation. I'll take the inline representation of my structure, duplicate it, and pass that inline representation to the function, or where the variable's storage is.  

This is how the Value Semantics work. Because you have your own peeled-off copy, you can do whatever you want with it and my pristine original is unaffacted


Classes though, are reference types.  When passing a reference type around, all you have to do is say "uh, hey, you can find this thing over there", giving it the address in memory where that object lives.  a.k.a. a pointer to the chunk of memory that has the object's properties.

This means the inline representation for class instances is going to be the size of a pointer, which is going to be 8 bytes (iOS, Mac, etc), or 4 bytes (on Playdate and other embedded systems)
</Text>
        </Document>
    </Documents>
</SearchIndexes>